\documentclass[xcolor=dvipsnames, aspectratio=1610, 9pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} % so that dollar sign does not turn into pound when italic!!
\usepackage{amsmath,amssymb,lmodern} % nice T1 compatible fonts
\usepackage[UKenglish]{babel}
\usepackage{ragged2e}%pour justifier le text, apr√®s il suffit de tapper \justifying avant le paragraphe
\setbeamertemplate{navigation symbols}{}%no nav symbols
\usetheme[secheader]{Madrid}%

\def\R{{\Large \bf R}}
\def\S{{\Large \bf S}}
\def\r{{\bf R}}
\def\s{{\bf S}}

\title{Getting to use data in \r}
\author[Alexandre Courtiol \& Colin Vullioud]{Alexandre Courtiol \& Colin Vullioud}
\institute[IZW]{Leibniz Institute of Zoo and Wildlife Research}%
\date[June 2018]{\small June 2018}%

\begin{document}
\setlength{\topsep}{1pt}%space between input and output
<<echo = FALSE, message = FALSE>>=
options(width = 60)
library(knitr)
opts_chunk$set("size" = "scriptsize")
library(dplyr)
@

\AtBeginSection[]{
     \begin{frame}
     \frametitle{Getting started with \R}
     \setcounter{tocdepth}{1}
     \tableofcontents[currentsection]
     \end{frame}
}

\AtBeginSubsection[]{
     \begin{frame}
     \frametitle{Getting started with \R}
     \setcounter{tocdepth}{2}
     \tableofcontents[currentsubsection]
     \end{frame}
}
% first slide of the doc
\maketitle

\section{Introduction}

\begin{frame}{Handling data in \r}
There are many types of objects designed to store data in \r.

\vspace{1em}
We will focus on:
\begin{itemize}
\item vectors
\item matrices (and arrays)
\item data frames (and tibbles)
\item list
\end{itemize}
\vfill
Note: if you master those, we are pretty much all set!
\end{frame}


\begin{frame}[fragile]{Handling data in \r}
\begin{itemize}
  \item vector
  \vfill
  \begin{itemize}
    \item A single row of data
    \item All elements have the same type (e.g. \texttt{numeric}, \texttt{factor}, \texttt{character}\dots)
  \end{itemize}
  \vfill
  \item \texttt{matrix} \& \texttt{array}
  \vfill
  \begin{itemize}
    \item All rows \& columns have same length
    \item All rows \& columns have the same type (\texttt{numeric} or \texttt{character})
  \end{itemize}
  \vfill
  \item \texttt{data.frame} \& \texttt{tibble}
  \vfill
  \begin{itemize}
    \item All rows \& columns have same length
    \item Each column can have its own type (\texttt{numeric}, \texttt{factor}, \texttt{character}\dots)
  \end{itemize}
  \vfill
  \item \texttt{list}
  \vfill
  \begin{itemize}
    \item Each element can have its own length
    \item Each element can have its own type (e.g. \texttt{numeric}, \texttt{factor}, \texttt{character}\dots)
  \end{itemize}
  \end{itemize}
  \vfill
\end{frame}


\section{Vectors}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Vector}
The vector is the simplest way to store data in \r; it is a sequence of data elements of the same kind.
\vfill
\begin{itemize}
\item Vectors allow the organisation of entities (e.g. numbers, characters. . . ) along one dimension which can be indexed:

  <<defining heights, echo = T>>=
height.girls <- c(178, 175, 159, 164, 183, 192)
height.boys <- c(181, 189, 174, 177)
@

  <<printing indexes height, echo = T>>=
height.girls[2]

height.boys[3]

@

  \end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Vector}
  \begin{itemize}
  \item They can be combined:

  << combining heights, echo = T>>=
(height <- c(height.boys, height.girls))
@

  \end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Vector continued}
  \begin{itemize}
  \item They can be indexed logically (i.e. indexed by anything leading to a vector of booleans):

  <<filtering heights, echo = T>>=
(height > 168)
@

  <<boolean heights, echo = T>>=
height[height > 168]
height[!(height == min(height))]
height[height != min(height)]
@

  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Types of vectors}
  \begin{itemize}
  \item character

  <<vector character, echo = T>>=
x <- c("bla", "1", "sf", "xx3")
str(x)
@
  \item factor
  <<vector factor, echo = T>>=
x <- as.factor(c("bla", "1", "sf", "xx3"))
str(x)
@

  \item logical
  <<vector logical, echo = T>>=
x <- c(TRUE, FALSE, T, F)
str(x)
@

  \item Dates
  <<vector dates, echo = T>>=
x <- c(as.Date("1999-01-12"), lubridate::ymd("1999-03-12"))
str(x)
@

  \end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{cool stuff with dates}
  \begin{itemize}
  \item Dates object
  <<Date objects, echo = T>>=
x
@
\item compute differences
  <<difference in time, echo = T>>=
x[1] - x[2]
as.numeric(x[1] - x[2])
@
  \item logical
  <<logical on dates, echo = T>>=
x[1] > x[2]

x[x > as.Date("1999-02-12")]
@
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Factors}
\begin{frame}[fragile]{Factors}
  \begin{itemize}
  \item They work with other things than numbers:

  << factors sex, echo = T>>=
sex <- c("girl","girl","girl","girl","girl", "girl",
"boy","boy","boy","boy")
sex <- factor(sex)
sex
@

  <<factors sex other options,echo = T>>=
# Or
sex <- factor(c(rep("girl", times = 6),
                rep("boy", times = 4)))
# Or

sex <- factor(c(rep("girl", times = length(height.girls)),
                rep("boy", times = length(height.boys))))
@

  \end{itemize}
\end{frame}

\begin{frame}[fragile]{Changing the order of levels of a factor}
  << changing levels order, echo = FALSE>>=
  my_factor1 <- factor(c("A", "A", "B", "B", "C"))
  my_factor2 <- factor(c("A", "A", "B", "B", "C"), levels = c("C", "B", "A"))
  @

  \begin{columns} % create columns
    \column{0.2\linewidth}
    \begin{center}
    You have:
    <<displaying factor1>>=
    my_factor1
    @
    \end{center}

    \column{0.2\linewidth}
    \begin{center}
    You want:
    <<displaying factor2>>=
    my_factor2
    @
    \end{center}
  \end{columns}

\pause

  \begin{columns}
    \column{0.5\linewidth}

    \begin{center}
    You do:
    <<solutions factors order>>=
    ## Using base:
    my_factor2 <- factor(my_factor1, levels(my_factor1)[c(3, 2, 1)])
    my_factor2
    @
    \end{center}
  \end{columns}
  \vfill

\pause

  Note:
  the order of levels influences the output of linear models and plotting functions (e.g. order in the legend of a ggplot) \dots
\end{frame}


\begin{frame}[fragile]{Changing the levels of a factor}
<<changing levels, echo = FALSE>>=
my_factor1 <- factor(c("A", "A", "B", "B", "C"))
my_factor2 <- factor(c("A", "A", "A", "A", "D"))
@

\begin{columns}
\column{0.2\linewidth}
\begin{center}
You have:
<<changing levels 1 >>=
my_factor1
@
\end{center}

\column{0.2\linewidth}
\begin{center}
You want:
<<changing levels 2>>=
my_factor2
@
\end{center}
\end{columns}

\begin{columns}
\column{0.5\linewidth}

\begin{center}
You do:
<<changing levels solution>>=
## Using base:
levels(my_factor1)
my_factor2 <- my_factor1
levels(my_factor2) <- c("A", "A", "D") ## in same order!
my_factor2
@

<<changing levels solutions dplyr>>=
## Using dplyr:
my_factor2 <- recode(my_factor1, A = "A", B = "A", C = "D")
my_factor2
@
\end{center}
\end{columns}

\end{frame}

\section{Matrices and arrays}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% begin section dataframe
\section{Data frames and tibbles}
\subsection{what is a data frame}
\begin{frame}[fragile]{Data frames}
\begin{center}
Data frames allow the organisation of entities as a matrix-like structure whose columns have the same length:
\end{center}
\vfill
<<create Data frame>>=

dataframe.ht <- data.frame(Height = height, Sex = sex)
dataframe.ht

@
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames}
\begin{center}
It is good practice to always check their structure:
\end{center}
<<str data frame, echo = T>>=
str(dataframe.ht)
@
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames}
\begin{center}
You access the columns by means of the extractor  \texttt{\$}
\vspace{1em}
\end{center}
<<access column df>>=
height
rm(list = c("height", "sex")) # removing original vectors
height
dataframe.ht$Height #Or: with(data = dataframe.ht, Height)
@
\vfill
\begin{center}
\textcolor{purple}{$\Rightarrow$ What is the average height?}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames}
Some functions can take a data frame as an input:
\vfill
<<summary df>>=
summary(dataframe.ht)
@
\vfill
Note: this will be the case of a lot of functions performing statistical tests!
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\
\begin{frame}[fragile]{Data frames}
How to compute the average height per sex?
\vfill
\begin{itemize}
\item simple
<<mean col df>>=
mean(dataframe.ht$Height[dataframe.ht$Sex == "boy"])
@
\item more elegant
<<mean col df2>>=
tapply(X = dataframe.ht$Height, INDEX = dataframe.ht$Sex,
       FUN = mean)
# Or: with(data = dataframe.ht, tapply(X = Height,
#   INDEX = Sex, FUN = mean))
@
\item even more elegant but dangerous
<<mean col df3>>=
library(dplyr)
dataframe.ht %>% group_by(Sex) %>% summarize(mean = mean(Height))  ## be aware of the rounding
@

\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\
\begin{frame}[fragile]{Data frames}
They can also be indexed:
\vspace{1em}
<<index df>>=
dataframe.ht[1, ]
dataframe.ht[, 1]  # Or: dataframe.ht[, "Sex"]
@
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames}
They can be edited:
\vspace{1em}
<<edit df>>=
dataframe.ht[1, 1]
dataframe.ht[1, 1] <- 171.3
dataframe.ht[1, 1]
dataframe.ht$linenumber <- 1:nrow(dataframe.ht)  # add column
ncol(dataframe.ht) # try dim()
dataframe.ht$linenumber <- NULL  # remove column
ncol(dataframe.ht)
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{dplyr}
\begin{frame}{dplyr}
\begin{itemize}
\item \texttt{dplyr} is a useful package for data manipulation
\vfill
\pause
\item \texttt{dplyr} is a grammar of data manipulation: one verb = one operation
\vfill
\pause
\item operations can be chained with the pipe operator \texttt{\%>\%}
\vfill
\pause
\item the pipe operator \texttt{\%>\%} takes the output from one function as input of another function.
\end{itemize}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames}
Useful \texttt{dplyr} verbs

\vspace{1em}
add column with \texttt{mutate()}
<<edit df dplyr>>=
dataframe.ht <- dataframe.ht %>% mutate(ID = 1:nrow(dataframe.ht))
head(dataframe.ht, n= 3)
@
\vspace{1em}

\pause

select columns with \texttt{select()}
<<select dplyr>>=
dataframe.ht.sex <- dataframe.ht %>% select(Sex)
head(dataframe.ht.sex, n= 3)
@
\vspace{1em}

\pause

select rows with \texttt{filter()}
<<filter dplyr>>=
dataframe.ht.female <- dataframe.ht %>% filter(Sex == "girl")
head(dataframe.ht.female, n= 3)
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{mutate\_if()}
you want to change all numeric variables into character variables
\vfill
\begin{columns}
\column{0.4\linewidth}
you have:
<<mutate if, echo = F >>=
x <- dataframe.ht %>%
  group_by(Sex) %>%
  mutate(mean_H = round(mean(Height, na.rm = T),2),
            median_H = round(median(Height, na.rm = T),2),
            n = n()) %>% ungroup() %>% mutate(Sex = as.character(Sex))
@
<<mutate if head, echo = F >>=
str(as.data.frame(x))
@
\column{0.5\linewidth}
you want
<<mutate if out, echo = F >>=

str(as.data.frame(x %>% mutate_if(is.numeric, ~ as.character(.))))
@
\end{columns}
\vfill
you do:
<<mutate if solution, echo = T>>=

x_numeric <- x %>% mutate_if(is.numeric, ~ as.character(.))
@
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{group\_by()}
\begin{itemize}
\item  \texttt{group\_by()} allow you to perform operation on gouped data.
\vfill
\pause
\item  it is mostly used with \texttt{summarize()} \texttt{->} one value per group
\vfill
\pause
\item  or with \texttt{mutate()} \texttt{->} one value per observation
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{group\_by() with summarize()}
\begin{center}
You want the mean height of males and females, the median height and the number in
each group:
\end{center}
\vfill
you do:
<<group_by summarize dplyr>>=
x <- dataframe.ht %>%
  group_by(Sex) %>%
  summarize(mean_H = mean(Height, na.rm = T),
            median_H = median(Height, na.rm = T),
            n = n())
@
\vfill
you get:
<<group_by summarize out>>=
as.data.frame(x)
@

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{group\_by() with mutate()}
\begin{center}
You want the mean height of males and females, the median height and the number in
each group but get the value for each individual
\end{center}
\vfill
you do:
<<group_by mutate dplyr>>=
x <- dataframe.ht %>%
  group_by(Sex) %>%
  mutate(mean_H = mean(Height, na.rm = T),
            median_H = median(Height, na.rm = T),
            n = n())
@
\vfill
you get:
<<group_by mutate out>>=
as.data.frame(x)
@

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{joining data frame}

 << merging df: creating df2, echo = F>>=
  set.seed(1)
   my_df1 <- data.frame(ID = paste("ID", 1:12, sep = "-"),
                        age = rnorm(12, mean = 15, sd = 4))

  my_df2 <- data.frame(ID = sample(my_df1$ID),
                       school = rep(c("Youhou", "bababa", "genius"), 4),
                       grade = round(rnorm(12, mean = 60, sd = 20), 2),
                       origin = sample(rep(c("Swiss", "French", "German"), 4)))

  my_df2 <- my_df2[1:10, ]
  my_df1 <- my_df1[c(1:6, 11), ]
  @
\begin{columns}
\column{0.3\linewidth}
\begin{center}
you have df1:
 << merging df df1, echo = T>>=
  my_df1
  @
\end{center}
\column{0.3\linewidth}
\begin{center}
you have df2:
 << merging df df2, echo = T>>=
  my_df2
  @
\end{center}
\end{columns}
\vfill
\begin{center}
You want to merge the two data frames
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{joining data frame with base R}
\begin{center}
You can use \texttt{merge()}
\end{center}
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
   << merging df with merge, echo = T>>=
  my_df3 <- merge(my_df1, my_df2)
  @
\end{center}
\column{0.3\linewidth}
\begin{center}
   << merging df with merge output, echo = T>>=
  my_df3
    @
\end{center}
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{joining data frame with dpylr join()}
\begin{center}
or use \texttt{inner\_join()}
\end{center}
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
   << merging df with dplyr join, echo = T>>=
  library(dplyr)
  my_df3 <- inner_join(my_df1, my_df2)
  @
\end{center}
\column{0.3\linewidth}
\begin{center}
   << merging df with merge dplyr join out, echo = T>>=
  my_df3
    @
\end{center}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{joining data frame with left\_join()}
\begin{center}
\texttt{left\_join() or right\_join()} keep all the rows of the data frame on the left (or right)
\end{center}
\begin{center}
adds NA when no data are present
\end{center}
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
<< left join, echo = T>>=
library(dplyr)
my_df3 <- left_join(my_df1, my_df2)
@
\end{center}
\column{0.3\linewidth}
\begin{center}
<< left join out, echo = T>>=
my_df3
@
\end{center}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{joining data frame with full\_join()}
\begin{center}
\texttt{full\_join()} keep all the rows of the two data frame
\end{center}
\begin{center}
adds NA when no data are present
\end{center}
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
   << full join, echo = T>>=
  library(dplyr)
  my_df3 <- full_join(my_df1, my_df2)
  @
\end{center}
\column{0.3\linewidth}
\begin{center}
   << full join out, echo = T>>=
  my_df3
    @
\end{center}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{tidyr}
\begin{frame}[fragile]{reshaping data frame}
\begin{itemize}
\item one row = one observation, one column = one variable
\pause
\vfill
\item \texttt{gather()} turns wide data into long
\pause
\vfill
\item \texttt{spread()} turns long data into wide
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{reshaping data frame}
 << reshaping data frame, echo = FALSE>>=
library(dplyr)
library(tidyr)
  my_df1 <- dataframe.ht %>%
    mutate(age1 = Height -100, age2 = Height -25, age3 = Height -10) %>%
    rename(age4 = Height) %>% select(ID, Sex, age1, age2, age3, age4) %>%
    filter(ID == 1)

  my_df2 <- my_df1 %>% gather("Age", "Height", 3:ncol(my_df1)) %>% arrange(ID, Age)

  @
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
you have wide data:
 << reshaping df1, echo = T>>=
  head(my_df1)
  dim(my_df1)
  @
\end{center}

\column{0.3\linewidth}
\begin{center}
you want long data:
 << reshaping df2, echo = T>>=
  head(my_df2)
  dim(my_df2)
  @
\end{center}
\end{columns}

\vfill
\pause
\begin{columns}
\column{0.5\linewidth}
\begin{center}
you do:
 << reshaping solution, echo = T>>=
 my_df2 <- my_df1 %>% gather("Age", "Height", -Sex, -ID) %>% arrange(ID, Age)
  @
\end{center}
\end{columns}
\pause
\begin{columns}
\column{0.5\linewidth}
\begin{center}
or:
 << reshaping solution bis, echo = T>>=
 my_df2 <- my_df1 %>% gather("Age", "Height", 3:ncol(my_df1)) %>% arrange(ID, Age)
  @
\end{center}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{reshaping data frame}
The reverse is done with \texttt{spread()}
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
you have wide data:
 << reshaping df1 spread, echo = T>>=
  head(my_df2)
  dim(my_df2)
  @
\end{center}

\column{0.3\linewidth}
\begin{center}
you want long data:
 << reshaping df2 spread, echo = T>>=
  head(my_df1)
  dim(my_df1)
  @
\end{center}
\end{columns}

\vfill
\pause
\begin{columns}
\column{0.5\linewidth}
\begin{center}
you do:
 << reshaping solution spread, echo = T>>=
 my_df2 %>% spread(-Sex, -ID)
  @
\end{center}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{some other useful functions}

\texttt{unite()} merges 2 columns of a data frame
 << unite, echo = T>>=
my_df3 <- my_df2 %>% unite(New_col, ID, Sex)
head(my_df3)
  @
\pause
\vfill
\texttt{separate()} separate 2 columns of a data frame
 << separate, echo = T>>=
my_df3 %>% separate(New_col, c("ID", "Sex"))
  @
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{cheating data frame}
\begin{center}
plenty of informative cheatsheets on: \url{https://www.rstudio.com/resources/cheatsheets/}
% \includegraphics[width=0.9\linewidth]{../figures/data-transformation.pdf}
\end{center}
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% begin section list
\section{List}
\begin{frame}[fragile]{Lists}
Lists allow the organisation of any set of entities into a single R object:
\vspace{1em}
<<>>=
list.ht <- list(girls = height.girls, boys = height.boys)
list.ht
@
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Lists}
Lists can also be indexed and their elements extracted:
\vspace{1em}
<<>>=
list.ht$girls
list.ht["boys"]  # still a list
list.ht[["boys"]]  # vector
list.ht[[2]][3]
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Lists}
Some functions can take a list as an input:
\vspace{1em}
<<>>=
lapply(list.ht, FUN = mean)
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Summary}
\begin{columns}
\column[t]{0.3\linewidth}
<<>>=
dataframe.ht
@
\column[t]{0.3\linewidth}
<<>>=
list.ht
@
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}[fragile]{Summary}
  \begin{itemize}
  \item \texttt{data.frame}
  \vfill
  \begin{itemize}
    \item All columns have same length
    \item Each column can have its own class (e.g. \texttt{numeric}, \texttt{factor}, \texttt{character})
  \end{itemize}
  \vfill
  \item \texttt{list}
  \vfill
  \begin{itemize}
    \item Each element can have its own length
    \item Each element can have its own class (e.g. \texttt{numeric}, \texttt{factor}, \texttt{character})
  \end{itemize}
  \vfill
  \end{itemize}
\end{frame}

\section{Importing \& exporting data}


\begin{frame}[fragile]{Working directory}
<<>>=
getwd()  # to change, use setwd()
dir() # listing all files in the working directory
dir(pattern = "*.csv")
@
\end{frame}


\begin{frame}[fragile]{Exporting and importing data in R}
<<tidy=F, eval = FALSE>>=
write.csv(dataframe.ht,
    file = "my.first.R.dataframe.csv", row.names = FALSE)

rm(list = ls())  # deleting everything in R

dataframe.ht <- read.csv("my.first.R.dataframe.csv")
@
\begin{center}
\begin{minipage}{0.8\linewidth}
\begin{block}{}
\begin{center}
R cannot read/write \*.xls files out of the box\\
Packages can do that but it is safer to use \*.csv files\\
Excel can read and write \*.csv files!\\
\end{center}
\end{block}
\end{minipage}
\end{center}
\vfill
\end{frame}

\begin{frame}{Challenge \#2}
\begin{large}
\begin{center}
Create a dataframe using your favorite spreadsheet software\\ and import it in R!
\end{center}
\end{large}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
