\documentclass[xcolor=dvipsnames, aspectratio=1610, 9pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} % so that dollar sign does not turn into pound when italic!!
\usepackage{amsmath,amssymb,lmodern} % nice T1 compatible fonts
\usepackage[UKenglish]{babel}
\usepackage{ragged2e}%pour justifier le text, apr√®s il suffit de tapper \justifying avant le paragraphe
\setbeamertemplate{navigation symbols}{}%no nav symbols
\usetheme[secheader]{Madrid}%

\def\R{{\Large \bf R}}
\def\S{{\Large \bf S}}
\def\r{{\bf R}}
\def\s{{\bf S}}

\title{Getting to use data in \r}
\author[Alexandre Courtiol \& Colin Vullioud]{Alexandre Courtiol \& Colin Vullioud}
\institute[IZW]{Leibniz Institute of Zoo and Wildlife Research}%
\date[June 2018]{\small June 2018}%

\begin{document}
\setlength{\topsep}{1pt}%space between input and output
<<echo = FALSE, message = FALSE>>=
options(width = 60)
library(knitr)
opts_chunk$set("size" = "scriptsize")
@

\AtBeginSection[]{
     \begin{frame}
     \frametitle{Getting started with \R}
     \setcounter{tocdepth}{1}
     \tableofcontents[currentsection]
     \end{frame}
}

\AtBeginSubsection[]{
     \begin{frame}
     \frametitle{Getting started with \R}
     \setcounter{tocdepth}{2}
     \tableofcontents[currentsubsection]
     \end{frame}
}
% first slide of the doc
\maketitle

\section{Introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Handling data in \r}
There are many types of objects designed to store data in \r.

\vspace{1em}
We will focus on:
\begin{itemize}
\item vectors
\item matrices (and arrays)
\item data frames (and tibbles)
\item lists
\end{itemize}
\vfill
Note: if you master those, we are pretty much all set because most other objects derive from those!
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Handling data in \r}
\begin{itemize}
  \item vectors
  \vfill
  \begin{itemize}
    \item a single row of data
    \item all elements have the same type (e.g. \texttt{logical}, \texttt{integer}, \texttt{double}, \texttt{character}\dots)
  \end{itemize}
  \vfill
  \item matrices (and arrays)
  \vfill
  \begin{itemize}
    \item all rows \& columns have same length
    \item all rows \& columns have the same type
  \end{itemize}
  \vfill
  \item data frames (and tibbles)
  \vfill
  \begin{itemize}
    \item all rows \& columns have same length
    \item each column can have its own type
  \end{itemize}
  \vfill
  \item lists
  \vfill
  \begin{itemize}
    \item each element can have its own length
    \item each element can have its own type
  \end{itemize}
  \end{itemize}
  \vfill
\end{frame}


\section{Vectors}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Vector}
\begin{center}
The vector is the simplest way to store data in \r; it is a sequence of data elements of the same kind.%
\end{center}
\vfill
Example of a vector:
<<defining heights, echo = T>>=
height_girls <- c(178, 175, 159, 164, 183, 192)
height_girls
@
\end{frame}

\subsection{general properties}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: general properties}
They can be combined:

\vfill
<< combining heights, echo = T>>=
height_boys <- c(181, 189, 174, 177)
height <- c(height_boys, height_girls)
height
@
\vfill
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: general properties}
Subsets can be made (with indexes, booleans or names):%

\vfill
<<printing indexes height, echo = T>>=
height_girls[2]  ## returns element 2
height_girls[-3] ## remove element 3
@
\vfill
\pause
<<boolean rep, echo = T>>=
height_girls[c(1, 1, 2, 2, 2)]  ## open room for bootstraps and more
@
\vfill
\pause
<<boolean heights, echo = T>>=
height_girls[height_girls > 168]
height_girls[!(height_girls == min(height_girls))]
height_girls[height_girls != min(height_girls)]
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[t, fragile]{Vector: general properties}
The elements of a vector can be named and those names can be used for subsetting:%

\vfill
<<>>=
foo <- c(alex = 1, colin = 2)
foo
foo["colin"]
@
\vfill
\pause
But names tend to be dropped in sometimes unexpected ways:
<<>>=
foo[1] + foo[2]
@
\vfill
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[t, fragile]{Vector: general properties}
Vectors can sometimes have metadata attached to them:
\vfill
<<>>=
foo <- c(1, 2, 3)
attr(foo, "whatever") <- "Learning to count"
attr(foo, "something else?") <- "nope"
@

<<>>=
foo
@
\pause
<<>>=
attr(foo, "whatever")
@
\pause
<<>>=
attributes(foo) ## this gives a list, see later!
@
\vfill
Note: this is useful to know for handling outputs in certain packages (e.g. \texttt{spaMM}).
\end{frame}


\subsection{types \& classes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: types}
Types refer to the internal representation of the objects:
\begin{columns}
\column{0.45\linewidth}
\begin{itemize}
\item logicals
<<>>=
(foo <- c(TRUE, FALSE, F, T))
typeof(foo)
@
\pause
\item integers
<<>>=
(foo <- c(1L, 5L, 7L, 0L))
typeof(foo)
@
\end{itemize}
\pause
\column{0.45\linewidth}
\begin{itemize}
\item doubles
<<>>=
(foo <- c(1, 1.2, pi))
typeof(foo)
@
\pause
\item characters
<<>>=
(foo <- c("bla", "bli", "blo"))
typeof(foo)
@
\end{itemize}
\end{columns}
\vfill
\pause
Note: \r \ detects automatically the type of input and creates the right type of vector for you!
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: classes}
Classes refer to the how functions interact with the objects:
\begin{columns}
\column{0.45\linewidth}
\begin{itemize}
\item logicals
<<>>=
(foo <- c(TRUE, FALSE, F, T))
class(foo)
@
\item integers
<<>>=
(foo <- c(1L, 5L, 7L, 0L))
class(foo)
@
\end{itemize}
\column{0.45\linewidth}
\begin{itemize}
\item numerics (from the type doubles)
<<>>=
(foo <- c(1, 1.2, pi))
class(foo)
@
\item characters
<<>>=
(foo <- c("bla", "bli", "blo"))
class(foo)
@
\end{itemize}
\end{columns}
\vfill
Note: many don't make the distinction between types and classes explicit but it helps to understand some weird behaviours of \r.
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: classes}
There are more classes than types:
\begin{columns}[t]
\column{0.45\linewidth}
\begin{itemize}
\item factors
<<>>=
(foo <- factor(c("bla", "bli", "blo")))
class(foo)
typeof(foo)
levels(foo)

levels(foo) <- c(levels(foo), "blu")  ## set extra level
table(foo)
@
\end{itemize}
\pause
\column{0.45\linewidth}
\begin{itemize}
\item dates
<<>>=
(foo <- c(as.Date("2018/06/18"),
          as.Date("19-06-18", format = "%d-%m-%y")))
class(foo)
typeof(foo)

foo + 50  ## you can do simple maths on dates!
@
\end{itemize}
\end{columns}
\vfill
\pause
Note: factors are heavily used in the context of linear models!
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: classes}
Vectors must contain elements of the same class (otherwise errors or automatic coercion may occur):%

\vfill
<<>>=
foo <- 1

bar <- "A"

foo_bar <- c(foo, bar)
foo_bar
@
\pause
\vfill
<<>>=
foo + 1

foo_bar[1] + 1
@
\pause
\vfill
Challenges:
\begin{itemize}
\item find out why the previous call produces an error.
\item try to check how the automatic coercion occurs by mixing different classes in different ways (logical, integers, numeric, characters, factors).
\item find out which date is internally stored as 0?
\end{itemize}
\end{frame}


\subsection{factors}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Factors}
You can create them after in two steps:
<< factors sex, echo = T>>=
sex <- c("girl","girl","girl","girl","girl", "girl",
"boy","boy","boy","boy")
class(sex)
@

<<>>=
sex <- factor(sex)
sex
@
\vfill
\pause
Better code:
<<factors sex other options,echo = T>>=
sex <- factor(c(rep("girl", times = 6),
                rep("boy", times = 4)))
@
\vfill
Even better code:
<<>>=
sex <- factor(c(rep("girl", times = length(height_girls)),
                rep("boy", times = length(height_boys))))
@
\vfill
Note: more on programming style later!
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Changing the order of levels of a factor}
<< changing levels order, echo = FALSE>>=
my_factor1 <- factor(c("A", "A", "B", "B", "C"))
my_factor2 <- factor(c("A", "A", "B", "B", "C"), levels = c("C", "B", "A"))
@

\begin{columns} % create columns
  \column{0.2\linewidth}
  \begin{center}
  You have:
  <<displaying factor1>>=
  my_factor1
  @
  \end{center}
  \column{0.2\linewidth}
  \begin{center}
  You want:
  <<displaying factor2>>=
  my_factor2
  @
  \end{center}
\end{columns}

\pause

  \begin{columns}
    \column{0.5\linewidth}

    \begin{center}
    You do:
    <<solutions factors order>>=
    my_factor2 <- factor(my_factor1, levels(my_factor1)[c(3, 2, 1)])
    my_factor2
    @
    \pause
    Or if you only care of the first level:
    <<solutions factors order 2>>=
    my_factor3 <- relevel(my_factor1, ref = "C")
    my_factor3
    @
    \end{center}
  \end{columns}
  \vfill

\pause

Note:
the order of levels influences the meaning of parameter estimates in linear models and some plotting functions (e.g. order in the legend of a ggplot) \dots
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Changing the levels of a factor}
<<changing levels, echo = FALSE>>=
my_factor1 <- factor(c("A", "A", "B", "B", "C"))
my_factor2 <- factor(c("A", "A", "A", "A", "D"))
@

\begin{columns}
\column{0.2\linewidth}
\begin{center}
You have:
<<changing levels 1 >>=
my_factor1
@
\end{center}

\column{0.2\linewidth}
\begin{center}
You want:
<<changing levels 2>>=
my_factor2
@
\end{center}
\end{columns}
\pause
\begin{columns}
\column{0.5\linewidth}

\begin{center}
You do:
<<changing levels solution>>=
## Using base:
levels(my_factor1)
my_factor2 <- my_factor1
levels(my_factor2) <- c("A", "A", "D") ## in same order!
my_factor2
@
\pause
<<changing levels solutions dplyr, message = FALSE>>=
## Using dplyr:
library(dplyr)
my_factor2 <- recode(my_factor1, A = "A", B = "A", C = "D")
my_factor2
@
\end{center}
\end{columns}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Some words about \texttt{dplyr} \& co.}
\texttt{dplyr} is part of the growing \texttt{tidyverse} world (\url{https://www.tidyverse.org/}) developped by RStudio:

\begin{center}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-dplyr"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-ggplot2"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-forcats"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-purrr"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-readr"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-stringr"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-tibble"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-tidyr"}
\end{center}
\pause
\begin{columns}[t]
\column{0.45\linewidth}
\begin{block}{\R \ core team}
\begin{itemize}
\item build the core of \r
\item backward compatibility is the priority
\item limited man power (20 selected volunteers)
\item not commercial (but Microsoft may creep in?)
\end{itemize}
\end{block}
\column{0.45\linewidth}
\begin{block}{RStudio}
\begin{itemize}
\item build RStudio \& the \texttt{tidyverse} packages
\item different philosophy: 1 function = 1 behaviour
\item backward compatibility is not the priority
\item 1 leader (Hadley Wickham) + $\sim$ 70 full time employees + tons of volunteers
\item free + commercial
\end{itemize}
\end{block}
\end{columns}
\pause
Note 1: that has led to two quite distinct \r \ dialects

Note 2: more and more users rely on \texttt{tidyverse}\dots

Note 3: we will see a bit of both dialects
\end{frame}

\subsection{functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Some simple functions for vectors}
<<>>=
foo <- c("bla", "bla", "bli")
bar <- c(1, 1.2, pi, NA)
@
\begin{columns}
\column{0.45\linewidth}
<<>>=
any(is.na(foo))
unique(foo)
length(foo)
str(foo)
summary(foo)
@
\pause
\column{0.45\linewidth}
<<>>=
any(is.na(bar))
unique(bar)
length(bar)
str(bar)
summary(bar)
@
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{A more complex function: \texttt{sapply()}}
\texttt{sapply()} is a function to apply a function on each element of a vector:
<<>>=
triple <- function(x) c(x, x, x)  ## let us create a sily function
triple("a")
@

<<>>=
sapply(X = bar, FUN = triple) ## here returns a matrix (automatic choice)
@
\pause
<<>>=
sapply(X = bar, FUN = triple, simplify = FALSE) ## same but always returns a list
@
\vfill
\pause
Note: this is useful when the function cannot work on vector and when the return is more than one element. For example, the input could be a vector of file names and the output one dataset per file!

Challenge: can you think of an alternative to do that without using \texttt{sapply()}? %subsetting
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{The \texttt{purrr} alternative to \texttt{sapply()}: \texttt{map()}}
<<>>=
library(purrr)
map(.x = bar, .f = triple) ## always returns a list
@
\pause
<<>>=
map_dfc(.x = bar, .f = triple) ## always returns a tibble binding columns
@
\end{frame}


\section{Matrices and arrays}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Matrices \& arrays}
\begin{center}
The matrices and arrays are direct extentions of vectors when there is more than one dimention \\ (1 or 2 dimensions for matrices, any for arrays).
\end{center}
\vfill
Example of a matrix:
<<>>=
my_matrix <- matrix(1:12, ncol = 4, nrow = 3)
my_matrix
class(my_matrix)
typeof(my_matrix) ## behind the curtain, matrices are stored as vectors!
@
\vfill
\pause
Note 1: since there are kind of vectors, same restriction: all elements must have the same class!

Note 2: useful for bulding the input of some statistical tests (e.g. chi-square), for linear algebra (e.g. computation behind linear models), for handling GIS information \& for understanding data frames.
\end{frame}


\subsection{general properties}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Matrices: general properties}
They can be combined:

\vfill
<<>>=
(my_2nd_matrix <- matrix(13:18, ncol = 2, nrow = 3))
(my_3rd_matrix <- matrix(1:4, nrow = 1))
@
<<>>=
cbind(my_matrix, my_2nd_matrix)  ## bind columns
@
<<>>=
rbind(my_matrix, my_3rd_matrix)  ## bind rows
@
\vfill
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: general properties}
Subsets can be made (with indexes, booleans or names):%

\vfill
<<>>=
my_matrix[2, ]
my_matrix[, 1]
my_matrix[3, , drop = FALSE]  ## to keep a matrix
my_matrix[2, 1]
my_matrix[c(1:2), c(1:2)]
@
\vfill
\pause
<<>>=
colnames(my_matrix) <- c("A", "B", "C", "D")
rownames(my_matrix) <- c("a", "b", "c")
my_matrix
my_matrix["b", ]
@
\end{frame}


\subsection{functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Some simple functions for matrices}
\begin{columns}[t]
\column{0.45\linewidth}
Dimensions:
<<>>=
dim(my_matrix)
ncol(my_matrix)
nrow(my_matrix)
length(my_matrix)
@
\vspace{1em}
Names:
<<>>=
colnames(my_matrix)
rownames(my_matrix)
@
\column{0.45\linewidth}
Linear algebra:
<<>>=
t(my_matrix)  ## transpose
my_matrix %*% c(1:4) ## matrix multiplication
diag(my_matrix) ## extract diagonal
@
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{A more complex function: \texttt{apply()}}
\texttt{apply()} is a function to apply a function on each row or column of a matrix:
<<>>=
apply(X = my_matrix, MARGIN = 1, FUN = mean)  ## row means
apply(X = my_matrix, MARGIN = 2, FUN = sd)  ## column SDs
@
\vfill
Note: \texttt{tidyverse} alternatives require to turn the matrix into a data frame, so we keep this for later.
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Arrays?}
Arrays are very similar to matrices but allow for more dimensions:
<<>>=
foo <- array(1:8, dim = c(2, 2, 2))
foo
@
\vfill
<<>>=
foo[1, 2, 2]
apply(X = foo, MARGIN = 3, FUN = sum)
@
\vfill
Note: only useful in some very specific situations.
\end{frame}


\section{Data frames and tibbles}
\subsection{what is a data frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames}
\begin{center}
Data frames allow the organisation of entities as a matrix-like structure whose columns have the same length:
\end{center}
\vfill
<<create Data frame>>=

dataframe.ht <- data.frame(Height = height, Sex = sex)
dataframe.ht

@
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames}
\begin{center}
It is good practice to always check their structure:
\end{center}
<<str data frame, echo = T>>=
str(dataframe.ht)
@
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames}
\begin{center}
You access the columns by means of the extractor  \texttt{\$}
\vspace{1em}
\end{center}
<<access column df>>=
height
rm(list = c("height", "sex")) # removing original vectors
height
dataframe.ht$Height #Or: with(data = dataframe.ht, Height)
@
\vfill
\begin{center}
\textcolor{purple}{$\Rightarrow$ What is the average height?}
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames}
Some functions can take a data frame as an input:
\vfill
<<summary df>>=
summary(dataframe.ht)
@
\vfill
Note: this will be the case of a lot of functions performing statistical tests!
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\
\begin{frame}[fragile]{Data frames}
How to compute the average height per sex?
\vfill
\begin{itemize}
\item simple
<<mean col df>>=
mean(dataframe.ht$Height[dataframe.ht$Sex == "boy"])
@
\item more elegant
<<mean col df2>>=
tapply(X = dataframe.ht$Height, INDEX = dataframe.ht$Sex,
       FUN = mean)
# Or: with(data = dataframe.ht, tapply(X = Height,
#   INDEX = Sex, FUN = mean))
@
\item even more elegant but dangerous
<<mean col df3>>=
library(dplyr)
dataframe.ht %>% group_by(Sex) %>% summarize(mean = mean(Height))  ## be aware of the rounding
@

\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\
\begin{frame}[fragile]{Data frames}
They can also be indexed:
\vspace{1em}
<<index df>>=
dataframe.ht[1, ]
dataframe.ht[, 1]  # Or: dataframe.ht[, "Sex"]
@
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames}
They can be edited:
\vspace{1em}
<<edit df>>=
dataframe.ht[1, 1]
dataframe.ht[1, 1] <- 171.3
dataframe.ht[1, 1]
dataframe.ht$linenumber <- 1:nrow(dataframe.ht)  # add column
ncol(dataframe.ht) # try dim()
dataframe.ht$linenumber <- NULL  # remove column
ncol(dataframe.ht)
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{dplyr}
\begin{frame}{dplyr}
\begin{itemize}
\item \texttt{dplyr} is a useful package for data manipulation
\vfill
\pause
\item \texttt{dplyr} is a grammar of data manipulation: one verb = one operation
\vfill
\pause
\item operations can be chained with the pipe operator \texttt{\%>\%}
\vfill
\pause
\item the pipe operator \texttt{\%>\%} takes the output from one function as input of another function.
\end{itemize}
\end{frame}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames}
Useful \texttt{dplyr} verbs

\vspace{1em}
add column with \texttt{mutate()}
<<edit df dplyr>>=
dataframe.ht <- dataframe.ht %>% mutate(ID = 1:nrow(dataframe.ht))
head(dataframe.ht, n= 3)
@
\vspace{1em}

\pause

select columns with \texttt{select()}
<<select dplyr>>=
dataframe.ht.sex <- dataframe.ht %>% select(Sex)
head(dataframe.ht.sex, n= 3)
@
\vspace{1em}

\pause

select rows with \texttt{filter()}
<<filter dplyr>>=
dataframe.ht.female <- dataframe.ht %>% filter(Sex == "girl")
head(dataframe.ht.female, n= 3)
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{mutate\_if()}
you want to change all numeric variables into character variables
\vfill
\begin{columns}
\column{0.4\linewidth}
you have:
<<mutate if, echo = F >>=
x <- dataframe.ht %>%
  group_by(Sex) %>%
  mutate(mean_H = round(mean(Height, na.rm = T),2),
            median_H = round(median(Height, na.rm = T),2),
            n = n()) %>% ungroup() %>% mutate(Sex = as.character(Sex))
@
<<mutate if head, echo = F >>=
str(as.data.frame(x))
@
\column{0.5\linewidth}
you want
<<mutate if out, echo = F >>=

str(as.data.frame(x %>% mutate_if(is.numeric, ~ as.character(.))))
@
\end{columns}
\vfill
you do:
<<mutate if solution, echo = T>>=

x_numeric <- x %>% mutate_if(is.numeric, ~ as.character(.))
@
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{group\_by()}
\begin{itemize}
\item  \texttt{group\_by()} allow you to perform operation on gouped data.
\vfill
\pause
\item  it is mostly used with \texttt{summarize()} \texttt{->} one value per group
\vfill
\pause
\item  or with \texttt{mutate()} \texttt{->} one value per observation
\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{group\_by() with summarize()}
\begin{center}
You want the mean height of males and females, the median height and the number in
each group:
\end{center}
\vfill
you do:
<<group_by summarize dplyr>>=
x <- dataframe.ht %>%
  group_by(Sex) %>%
  summarize(mean_H = mean(Height, na.rm = T),
            median_H = median(Height, na.rm = T),
            n = n())
@
\vfill
you get:
<<group_by summarize out>>=
as.data.frame(x)
@

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{group\_by() with mutate()}
\begin{center}
You want the mean height of males and females, the median height and the number in
each group but get the value for each individual
\end{center}
\vfill
you do:
<<group_by mutate dplyr>>=
x <- dataframe.ht %>%
  group_by(Sex) %>%
  mutate(mean_H = mean(Height, na.rm = T),
            median_H = median(Height, na.rm = T),
            n = n())
@
\vfill
you get:
<<group_by mutate out>>=
as.data.frame(x)
@

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{joining data frame}

 << merging df: creating df2, echo = F>>=
  set.seed(1)
   my_df1 <- data.frame(ID = paste("ID", 1:12, sep = "-"),
                        age = rnorm(12, mean = 15, sd = 4))

  my_df2 <- data.frame(ID = sample(my_df1$ID),
                       school = rep(c("Youhou", "bababa", "genius"), 4),
                       grade = round(rnorm(12, mean = 60, sd = 20), 2),
                       origin = sample(rep(c("Swiss", "French", "German"), 4)))

  my_df2 <- my_df2[1:10, ]
  my_df1 <- my_df1[c(1:6, 11), ]
  @
\begin{columns}
\column{0.3\linewidth}
\begin{center}
you have df1:
 << merging df df1, echo = T>>=
  my_df1
  @
\end{center}
\column{0.3\linewidth}
\begin{center}
you have df2:
 << merging df df2, echo = T>>=
  my_df2
  @
\end{center}
\end{columns}
\vfill
\begin{center}
You want to merge the two data frames
\end{center}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{joining data frame with base R}
\begin{center}
You can use \texttt{merge()}
\end{center}
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
   << merging df with merge, echo = T>>=
  my_df3 <- merge(my_df1, my_df2)
  @
\end{center}
\column{0.3\linewidth}
\begin{center}
   << merging df with merge output, echo = T>>=
  my_df3
    @
\end{center}
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{joining data frame with dpylr join()}
\begin{center}
or use \texttt{inner\_join()}
\end{center}
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
   << merging df with dplyr join, echo = T>>=
  library(dplyr)
  my_df3 <- inner_join(my_df1, my_df2)
  @
\end{center}
\column{0.3\linewidth}
\begin{center}
   << merging df with merge dplyr join out, echo = T>>=
  my_df3
    @
\end{center}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{joining data frame with left\_join()}
\begin{center}
\texttt{left\_join() or right\_join()} keep all the rows of the data frame on the left (or right)
\end{center}
\begin{center}
adds NA when no data are present
\end{center}
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
<< left join, echo = T>>=
library(dplyr)
my_df3 <- left_join(my_df1, my_df2)
@
\end{center}
\column{0.3\linewidth}
\begin{center}
<< left join out, echo = T>>=
my_df3
@
\end{center}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{joining data frame with full\_join()}
\begin{center}
\texttt{full\_join()} keep all the rows of the two data frame
\end{center}
\begin{center}
adds NA when no data are present
\end{center}
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
   << full join, echo = T>>=
  library(dplyr)
  my_df3 <- full_join(my_df1, my_df2)
  @
\end{center}
\column{0.3\linewidth}
\begin{center}
   << full join out, echo = T>>=
  my_df3
    @
\end{center}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{tidyr}
\begin{frame}[fragile]{reshaping data frame}
\begin{itemize}
\item one row = one observation, one column = one variable
\pause
\vfill
\item \texttt{gather()} turns wide data into long
\pause
\vfill
\item \texttt{spread()} turns long data into wide
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{reshaping data frame}
 << reshaping data frame, echo = FALSE>>=
library(dplyr)
library(tidyr)
  my_df1 <- dataframe.ht %>%
    mutate(age1 = Height -100, age2 = Height -25, age3 = Height -10) %>%
    rename(age4 = Height) %>% select(ID, Sex, age1, age2, age3, age4) %>%
    filter(ID == 1)

  my_df2 <- my_df1 %>% gather("Age", "Height", 3:ncol(my_df1)) %>% arrange(ID, Age)

  @
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
you have wide data:
 << reshaping df1, echo = T>>=
  head(my_df1)
  dim(my_df1)
  @
\end{center}

\column{0.3\linewidth}
\begin{center}
you want long data:
 << reshaping df2, echo = T>>=
  head(my_df2)
  dim(my_df2)
  @
\end{center}
\end{columns}

\vfill
\pause
\begin{columns}
\column{0.5\linewidth}
\begin{center}
you do:
 << reshaping solution, echo = T>>=
 my_df2 <- my_df1 %>% gather("Age", "Height", -Sex, -ID) %>% arrange(ID, Age)
  @
\end{center}
\end{columns}
\pause
\begin{columns}
\column{0.5\linewidth}
\begin{center}
or:
 << reshaping solution bis, echo = T>>=
 my_df2 <- my_df1 %>% gather("Age", "Height", 3:ncol(my_df1)) %>% arrange(ID, Age)
  @
\end{center}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{reshaping data frame}
The reverse is done with \texttt{spread()}
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
you have wide data:
 << reshaping df1 spread, echo = T>>=
  head(my_df2)
  dim(my_df2)
  @
\end{center}

\column{0.3\linewidth}
\begin{center}
you want long data:
 << reshaping df2 spread, echo = T>>=
  head(my_df1)
  dim(my_df1)
  @
\end{center}
\end{columns}

\vfill
\pause
\begin{columns}
\column{0.5\linewidth}
\begin{center}
you do:
 << reshaping solution spread, echo = T>>=
 my_df2 %>% spread(-Sex, -ID)
  @
\end{center}
\end{columns}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{some other useful functions}

\texttt{unite()} merges 2 columns of a data frame
 << unite, echo = T>>=
my_df3 <- my_df2 %>% unite(New_col, ID, Sex)
head(my_df3)
  @
\pause
\vfill
\texttt{separate()} separate 2 columns of a data frame
 << separate, echo = T>>=
my_df3 %>% separate(New_col, c("ID", "Sex"))
  @
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}{cheating data frame}
\begin{center}
plenty of informative cheatsheets on: \url{https://www.rstudio.com/resources/cheatsheets/}
% \includegraphics[width=0.9\linewidth]{../figures/data-transformation.pdf}
\end{center}
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% begin section list
\section{List}
\begin{frame}[fragile]{Lists}
Lists allow the organisation of any set of entities into a single R object:
\vspace{1em}
<<>>=
list.ht <- list(girls = height_girls, boys = height_boys)
list.ht
@
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Lists}
Lists can also be indexed and their elements extracted:
\vspace{1em}
<<>>=
list.ht$girls
list.ht["boys"]  # still a list
list.ht[["boys"]]  # vector
list.ht[[2]][3]
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Lists}
Some functions can take a list as an input:
\vspace{1em}
<<>>=
lapply(list.ht, FUN = mean)
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Summary}
\begin{columns}
\column[t]{0.3\linewidth}
<<>>=
dataframe.ht
@
\column[t]{0.3\linewidth}
<<>>=
list.ht
@
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{frame}[fragile]{Summary}
  \begin{itemize}
  \item \texttt{data.frame}
  \vfill
  \begin{itemize}
    \item All columns have same length
    \item Each column can have its own class (e.g. \texttt{numeric}, \texttt{factor}, \texttt{character})
  \end{itemize}
  \vfill
  \item \texttt{list}
  \vfill
  \begin{itemize}
    \item Each element can have its own length
    \item Each element can have its own class (e.g. \texttt{numeric}, \texttt{factor}, \texttt{character})
  \end{itemize}
  \vfill
  \end{itemize}
\end{frame}

\section{Importing \& exporting data}


\begin{frame}[fragile]{Working directory}
<<>>=
getwd()  # to change, use setwd()
dir() # listing all files in the working directory
dir(pattern = "*.csv")
@
\end{frame}


\begin{frame}[fragile]{Exporting and importing data in R}
<<tidy=F, eval = FALSE>>=
write.csv(dataframe.ht,
    file = "my.first.R.dataframe.csv", row.names = FALSE)

rm(list = ls())  # deleting everything in R

dataframe.ht <- read.csv("my.first.R.dataframe.csv")
@
\begin{center}
\begin{minipage}{0.8\linewidth}
\begin{block}{}
\begin{center}
R cannot read/write \*.xls files out of the box\\
Packages can do that but it is safer to use \*.csv files\\
Excel can read and write \*.csv files!\\
\end{center}
\end{block}
\end{minipage}
\end{center}
\vfill
\end{frame}

\begin{frame}{Challenge \#2}
\begin{large}
\begin{center}
Create a dataframe using your favorite spreadsheet software\\ and import it in R!
\end{center}
\end{large}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
