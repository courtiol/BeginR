\documentclass[xcolor=dvipsnames, aspectratio=1610, 9pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} % so that dollar sign does not turn into pound when italic!!
\usepackage{amsmath,amssymb,lmodern} % nice T1 compatible fonts
\usepackage[UKenglish]{babel}
\usepackage{ragged2e}%pour justifier le text, apr√®s il suffit de tapper \justifying avant le paragraphe
\setbeamertemplate{navigation symbols}{}%no nav symbols
\usetheme[secheader]{Madrid}%

\def\R{{\Large \bf R}}
\def\S{{\Large \bf S}}
\def\r{{\bf R}}
\def\s{{\bf S}}

\title{Getting to use data in \r}
\author[Alexandre Courtiol \& Colin Vullioud]{Alexandre Courtiol \& Colin Vullioud}
\institute[IZW]{Leibniz Institute of Zoo and Wildlife Research}%
\date[June 2018]{\small June 2018}%

\begin{document}
\setlength{\topsep}{1pt}%space between input and output
<<echo = FALSE, message = FALSE>>=
options(width = 60)
library(knitr)
opts_chunk$set("size" = "scriptsize")
@

\AtBeginSection[]{
     \begin{frame}
     \frametitle{Getting started with \R}
     \setcounter{tocdepth}{1}
     \tableofcontents[currentsection]
     \end{frame}
}

\AtBeginSubsection[]{
     \begin{frame}
     \frametitle{Getting started with \R}
     \setcounter{tocdepth}{2}
     \tableofcontents[currentsubsection]
     \end{frame}
}
% first slide of the doc
\maketitle

\section{Introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Handling data in \r}
There are many types of objects designed to store data in \r.

\vspace{1em}
We will focus on:
\begin{itemize}
\item vectors
\item matrices (and arrays)
\item data frames (and tibbles)
\item lists
\end{itemize}
\vfill
Note: if you master those, we are pretty much all set because most other objects derive from those!
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Handling data in \r}
\begin{itemize}
  \item vectors
  \vfill
  \begin{itemize}
    \item a single row of data
    \item all elements have the same type (e.g. \texttt{logical}, \texttt{integer}, \texttt{double}, \texttt{character}\dots)
  \end{itemize}
  \vfill
  \item matrices (and arrays)
  \vfill
  \begin{itemize}
    \item all rows \& columns have same length
    \item all rows \& columns have the same type
  \end{itemize}
  \vfill
  \item data frames (and tibbles)
  \vfill
  \begin{itemize}
    \item all rows \& columns have same length
    \item each column can have its own type
  \end{itemize}
  \vfill
  \item lists
  \vfill
  \begin{itemize}
    \item each element can have its own length
    \item each element can have its own type
  \end{itemize}
  \end{itemize}
  \vfill
\end{frame}


\section{Vectors}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Vector}
\begin{center}
The vector is the simplest way to store data in \r; it is a sequence of data elements of the same kind.%
\end{center}
\vfill
Example of a vector:
<<defining heights, echo = T>>=
height_girls <- c(178, 175, 159, 164, 183, 192)
height_girls
@
\end{frame}

\subsection{general properties}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: general properties}
They can be combined:

\vfill
<< combining heights, echo = T>>=
height_boys <- c(181, 189, 174, 177)
height <- c(height_boys, height_girls)
height
@
\vfill
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: general properties}
Subsets can be made (with indexes, booleans or names):%

\vfill
<<printing indexes height, echo = T>>=
height_girls[2]  ## returns element 2
height_girls[-3] ## remove element 3
@
\vfill
\pause
<<boolean rep, echo = T>>=
height_girls[c(1, 1, 2, 2, 2)]  ## open room for bootstraps and more
@
\vfill
\pause
<<boolean heights, echo = T>>=
height_girls[height_girls > 168]
height_girls[!(height_girls == min(height_girls))]
height_girls[height_girls != min(height_girls)]
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[t, fragile]{Vector: general properties}
The elements of a vector can be named and those names can be used for subsetting:%

\vfill
<<>>=
foo <- c(alex = 1, colin = 2)
foo
foo["colin"]
@
\vfill
\pause
But names behave sometimes somewhat unexpectedly:
<<>>=
foo[1] + foo[2]
@
\vfill
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[t, fragile]{Vector: general properties}
Vectors (as any other object) can have metadata called `attributes' attached to them:
\vfill
<<>>=
foo <- c(1, 2, 3)
attr(x = foo, which = "whatever") <- "Learning to count"
attr(x = foo, which = "something else?") <- "nope"
@

<<>>=
foo
@
\pause
<<>>=
attr(x = foo, which = "whatever")
@
\pause
<<>>=
attributes(foo) ## this gives a list, see later!
@
\vfill
Note: this is useful to know for handling outputs in certain packages (e.g. \texttt{spaMM}).
\end{frame}


\subsection{types \& classes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: types}
Types refer to the internal representation of the objects:
\begin{columns}
\column{0.45\linewidth}
\begin{itemize}
\item logicals
<<>>=
(foo <- c(TRUE, FALSE, F, T))
typeof(x = foo)
@
\pause
\item integers
<<>>=
(foo <- c(1L, 5L, 7L, 0L))
typeof(x = foo)
@
\end{itemize}
\pause
\column{0.45\linewidth}
\begin{itemize}
\item doubles
<<>>=
(foo <- c(1, 1.2, pi))
typeof(x = foo)
@
\pause
\item characters
<<>>=
(foo <- c("bla", "bli", "blo"))
typeof(x = foo)
@
\end{itemize}
\end{columns}
\vfill
\pause
Note: \r \ detects automatically the type of input and creates the right type of vector for you!
\vspace{1em}
Challenge: compare \texttt{typeof()} with \texttt{mode()}. % mode is the same except that doubles and integers are called numerics (and a few other name changes)
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: classes}
Classes refer to the how functions interact with the objects:
\begin{columns}
\column{0.45\linewidth}
\begin{itemize}
\item logicals
<<>>=
(foo <- c(TRUE, FALSE, F, T))
class(x = foo)
@
\item integers
<<>>=
(foo <- c(1L, 5L, 7L, 0L))
class(x = foo)
@
\end{itemize}
\column{0.45\linewidth}
\begin{itemize}
\item numerics (from the type doubles)
<<>>=
(foo <- c(1, 1.2, pi))
class(x = foo)
@
\item characters
<<>>=
(foo <- c("bla", "bli", "blo"))
class(x = foo)
@
\end{itemize}
\end{columns}
\vfill
Note: many don't make the distinction between types and classes explicit but it helps to understand some weird behaviours of \r.
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: classes}
There are more classes than types:
\begin{columns}[t]
\column{0.45\linewidth}
\begin{itemize}
\item factors
<<>>=
(foo <- factor(c("bla", "bli", "blo")))
class(x = foo)
typeof(x = foo)
levels(x = foo)

levels(x = foo) <- c(levels(x = foo), "blu")  ## set extra level
table(foo)
@
\end{itemize}
\pause
\column{0.45\linewidth}
\begin{itemize}
\item dates
<<>>=
(foo <- c(as.Date(x = "2018/06/18"),
          as.Date(x = "19-06-18", format = "%d-%m-%y")))
class(x = foo)
typeof(x = foo)

foo + 50  ## you can do simple maths on dates!
@
\end{itemize}
\end{columns}
\vfill
\pause
Note: factors are heavily used in the context of linear models!
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: classes}
Vectors must contain elements of the same class (otherwise errors or automatic coercion may occur):%

\vfill
<<>>=
foo <- 1

bar <- "A"

foo_bar <- c(foo, bar)
foo_bar
@
\pause
\vfill
<<>>=
foo + 1

foo_bar[1] + 1
@
\pause
\vfill
Challenges:
\begin{itemize}
\item find out why the previous call produces an error.
\item try to check how the automatic coercion occurs by mixing different classes in different ways (logical, integers, numeric, characters, factors).
\item find out which date is internally stored as 0?
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: classes}
Some coercions are straightforward:
<<>>=
as.integer(x = 1.2)
as.integer(x = 1.9)
as.integer(x = -2.1)
@
\vfill
<<>>=
foo <- factor(x = 10:20)
foo
as.character(x = foo)
@
\vfill
\pause
But not all:
<<>>=
as.numeric(x = foo)
as.numeric(as.character(x = foo))
@
\vfill
<<>>=
foo <- as.Date(x = "20180618", format = "%Y%m%d")
as.integer(x = foo)
as.integer(x = gsub(pattern = "-", replacement = "", x = as.character(foo)))
@
\end{frame}


\subsection{factors}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Factors}
You can create them after in two steps:
<< factors sex, echo = T>>=
sex <- c("girl","girl","girl","girl","girl", "girl",
"boy","boy","boy","boy")
class(x = sex)
@

<<>>=
sex <- factor(x = sex)
sex
@
\vfill
\pause
Better code:
<<factors sex other options,echo = T>>=
sex <- factor(x = c(rep(x = "girl", times = 6),
                    rep(x = "boy", times = 4)))
@
\vfill
Even better code:
<<>>=
sex <- factor(x = c(rep(x = "girl", times = length(x = height_girls)),
                    rep(x = "boy", times = length(x = height_boys))))
@
\vfill
Note: more on programming style later!
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Changing the order of levels of a factor}
<< changing levels order, echo = FALSE>>=
my_factor1 <- factor(x = c("A", "A", "B", "B", "C"))
my_factor2 <- factor(x = c("A", "A", "B", "B", "C"), levels = c("C", "B", "A"))
@

\begin{columns} % create columns
  \column{0.2\linewidth}
  \begin{center}
  You have:
  <<displaying factor1>>=
  my_factor1
  @
  \end{center}
  \column{0.2\linewidth}
  \begin{center}
  You want:
  <<displaying factor2>>=
  my_factor2
  @
  \end{center}
\end{columns}

\pause

  \begin{columns}
    \column{0.5\linewidth}

    \begin{center}
    You do:
    <<solutions factors order>>=
    my_factor2 <- factor(x = my_factor1, levels = levels(my_factor1)[c(3, 2, 1)])
    my_factor2
    @
    \pause
    Or if you only care about the first level:
    <<solutions factors order 2>>=
    my_factor3 <- relevel(x = my_factor1, ref = "C")
    my_factor3
    @
    \end{center}
  \end{columns}
  \vfill

\pause

Note:
the order of levels influences the meaning of parameter estimates in linear models and some plotting functions (e.g. order in the legend of a ggplot) \dots
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Changing the levels of a factor}
<<changing levels, echo = FALSE>>=
my_factor1 <- factor(x = c("A", "A", "B", "B", "C"))
my_factor2 <- factor(x = c("A", "A", "A", "A", "D"))
@

\begin{columns}
\column{0.2\linewidth}
\begin{center}
You have:
<<changing levels 1 >>=
my_factor1
@
\end{center}

\column{0.2\linewidth}
\begin{center}
You want:
<<changing levels 2>>=
my_factor2
@
\end{center}
\end{columns}
\pause
\begin{columns}
\column{0.5\linewidth}

\begin{center}
You do:
<<changing levels solution>>=
## Using base:
levels(x = my_factor1)
my_factor2 <- my_factor1
levels(x = my_factor2) <- c("A", "A", "D") ## in same order!
my_factor2
@
\pause
<<changing levels solutions dplyr, message = FALSE>>=
## Using dplyr:
library(dplyr)
my_factor2 <- recode(.x = my_factor1, A = "A", B = "A", C = "D")
my_factor2
@
\end{center}
\end{columns}

\end{frame}


\subsection{functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Some simple functions for vectors}
<<>>=
foo <- c("bla", "bla", "bli")
bar <- c(1, 1.2, pi, NA)
@
\begin{columns}
\column{0.45\linewidth}
<<>>=
any(is.na(x = foo))
unique(x = foo)
length(x = foo)
str(object = foo)
summary(object = foo)
@
\pause
\column{0.45\linewidth}
<<>>=
any(is.na(x = bar))
unique(x = bar)
length(x = bar)
str(object = bar)
summary(object = bar)
@
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{A more complex function: \texttt{sapply()}}
\texttt{sapply()} is a function to apply a function on each element of a vector:
<<>>=
triple <- function(x) c(x, x, x)  ## let us create a sily function
triple(x = "a")
@

<<>>=
sapply(X = bar, FUN = triple) ## here returns a matrix (automatic choice)
@
\pause
<<>>=
sapply(X = bar, FUN = triple, simplify = FALSE) ## same but always returns a list
@
\vfill
\pause
Note: this is useful when the function cannot work on vector and when the return is more than one element. For example, the input could be a vector of file names and the output one dataset per file!
\vfill
Challenge: can you think of an alternative to do that without using \texttt{sapply()}? %subsetting
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{The \texttt{purrr} alternative to \texttt{sapply()}: \texttt{purrr::map()}}
<<>>=
library(purrr)
map(.x = bar, .f = triple) ## always returns a list
@
\pause
<<>>=
map_dfc(.x = bar, .f = triple) ## always returns a tibble binding columns
@
\end{frame}


\section{Matrices and arrays}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Matrices \& arrays}
\begin{center}
The matrices and arrays are direct extentions of vectors when there is more than one dimension \\ (1 or 2 dimensions for matrices, any for arrays).
\end{center}
\vfill
Example of a matrix:
<<>>=
my_matrix <- matrix(data = 1:12, ncol = 4, nrow = 3)
my_matrix
class(x = my_matrix)
typeof(x = my_matrix) ## behind the curtain, matrices are stored as vectors!
@
\vfill
\pause
Note 1: since there are a kind of vectors, the same restrictions apply: all elements must have the same class!

Note 2: useful for bulding the input of some statistical tests (e.g. chi-square), for linear algebra (e.g. computation behind linear models), for handling GIS information \& for understanding data frames.
\end{frame}


\subsection{general properties}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Matrices: general properties}
They can be combined:

\vfill
<<>>=
(my_2nd_matrix <- matrix(data = 13:18, ncol = 2, nrow = 3))
(my_3rd_matrix <- matrix(data = 1:4, nrow = 1))
@
\vfill
\pause
<<>>=
cbind(my_matrix, my_2nd_matrix)  ## bind columns
@
\pause
\vfill
<<>>=
rbind(my_matrix, my_3rd_matrix)  ## bind rows
@
\vfill
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Matrices: general properties}
Subsets can be made (with indexes, booleans or names):%

\vfill
<<>>=
my_matrix[2, ]
my_matrix[, 1]
my_matrix[3, , drop = FALSE]  ## to keep a matrix
my_matrix[2, 1]
my_matrix[c(1:2), c(1:2)]
@
\vfill
\pause
<<>>=
colnames(x = my_matrix) <- c("A", "B", "C", "D")
rownames(x = my_matrix) <- c("a", "b", "c")
my_matrix
my_matrix["b", ]
@
\end{frame}


\subsection{functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Some simple functions for matrices}
\begin{columns}[t]
\column{0.45\linewidth}
Dimensions:
<<>>=
dim(x = my_matrix)
ncol(x = my_matrix)
nrow(x = my_matrix)
length(x = my_matrix)
@
\vspace{1em}
Names:
<<>>=
colnames(x = my_matrix)
rownames(x = my_matrix)
@
\column{0.45\linewidth}
Linear algebra:
<<>>=
t(x = my_matrix)  ## transpose
my_matrix %*% c(1:4) ## matrix multiplication
diag(x = my_matrix) ## extract diagonal
@
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{A more complex function: \texttt{apply()}}
\texttt{apply()} is a function to apply a function on each row or column of a matrix:
<<>>=
apply(X = my_matrix, MARGIN = 1, FUN = mean)  ## row means
apply(X = my_matrix, MARGIN = 2, FUN = sd)  ## column SDs
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Arrays?}
Arrays are very similar to matrices but allow for more dimensions:
<<>>=
foo <- array(data = 1:8, dim = c(2, 2, 2))
foo
@
\vfill
<<>>=
foo[1, 2, 2]
apply(X = foo, MARGIN = 3, FUN = sum)
@
\vfill
Note: only useful in some very specific situations.
\end{frame}


\section{List}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Lists}
\begin{center}
Lists allow the organisation of any set of entities into a single \r \ object.
\end{center}
\vfill
Example of a list:
<<>>=
list_height <- list(height_girls, height_boys)
list_height
class(x = list_height)
typeof(x = list_height)
@
\vfill
Note 1: list elements can be anything!\\
\vspace{1em}
Note 2: lists are very important because no function can output more than one object!
\end{frame}


\subsection{general properties}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Lists: general properties}
They can be combined:
\vfill
<<>>=
list_full <- c(list_height, list(my_matrix))
list_full
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Lists: general properties}
Subsets can be made (with indexes, booleans or names):%
\vfill
<<>>=
list_height <- list(girls = height_girls, boys = height_boys)  ## create a list with names
list_height
@
\vfill
<<>>=
list_height$girls
@
<<>>=
list_height["boys"] ## still a list
@
<<>>=
list_height[["boys"]] ## vector
@
<<>>=
list_height[[2]][3]
@
\vfill
\end{frame}


\subsection{functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Some simple functions for lists}
<<>>=
length(x = list_full) ## number of elements
@
<<>>=
str(object = list_full)  ## this function is really useful!
@
\vfill
Challenge: run the examples from \texttt{lm()} and explore the list \texttt{lm.D9}.
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{A more complex function: \texttt{lapply()}}
\texttt{lapply()} is a function to apply a function on each element of a list:
<<>>=
lapply(X = list_full, FUN = mean)
@
\end{frame}



\section{Data frames and tibbles}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames}
\begin{center}
Data frames allow the organisation of vectors of the same length as a matrix-like structure:
\end{center}
\vfill
Example:
<<create Data frame>>=
dataframe_ht <- data.frame(Height = height, Sex = sex)
dataframe_ht
class(dataframe_ht)
typeof(dataframe_ht)
@
\pause
\vfill
Note 1: this is the best choice of representation for datasets!\\
\vspace{1em}
Note 2: it is safer to work on data frames than on floating vectors!
\end{frame}


\subsection{general properties}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Data frames: general properties}
They borough from both matrices and lists:
\vfill
\begin{columns}[t]
\column{0.45\linewidth}
As for matrices:
<<>>=
(dataframe_ht_double <- cbind(dataframe_ht, newcol = 1:10))
@
\pause
<<>>=
dataframe_ht[, "Sex"]
dataframe_ht[2, 2]
@
\pause
\column{0.45\linewidth}
As for lists:
<<>>=
dataframe_ht$Height
str(dataframe_ht)
@

\end{columns}
\end{frame}


\subsection{challenge}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames: challenge}
The \texttt{iris} data set:
<<>>=
head(iris) ## this function displays the first 6 rows
@
\vfill
Using the \texttt{iris} data frame, find out:
\begin{itemize}
\item what is the average sepal length across all flowers?
\item what is the median sepal length across \emph{Iris versicolor}?
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames: general properties}
Data frames can easily be edited:
<<edit df>>=
backup <- dataframe_ht[1, 1]
dataframe_ht[1, 1] <- 171.3
dataframe_ht[1, 1]
dataframe_ht[1, 1] <- backup
dataframe_ht[1, 1]
@
\pause
<<>>=
dataframe_ht$linenumber <- 1:nrow(x = dataframe_ht)  # add column
head(x = dataframe_ht)
@
\pause
<<>>=
dataframe_ht$linenumber <- NULL  # remove column
head(x = dataframe_ht)
@
\end{frame}


\subsection{functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Some simple functions for data frames}
\begin{columns}[t]
\column{0.45\linewidth}
<<summary df>>=
head(x = iris)  ## try also tail()
summary(object = iris)
@
\column{0.45\linewidth}
<<>>=
dim(x = iris)
ncol(x = iris)
nrow(x = iris)
length(x = iris) ## not as in matrix!!
rownames(x = iris)[1:10]
colnames(x = iris)
@
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{A more complex function: \texttt{tapply()}}
\texttt{tapply()} is a function to apply a function on subsets of a given column from the data frame:
<<>>=
tapply(X = iris$Sepal.Length, INDEX = iris$Species, FUN = mean)
@
\vfill
\pause
Or similarly:
<<>>=
with(data = iris, tapply(X = Sepal.Length, INDEX = Species, FUN = mean))
@
\vfill
\pause
Or similarly:
<<>>=
by(data = iris, INDICES = iris$Species, FUN = function(x) mean(x$Sepal.Length))
@
\vfill
Note: \texttt{by()} is more powerful but more complex than \texttt{tapply()}.
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{The \texttt{dyplr} alternative to \texttt{tapply()}}
The same operation in \texttt{dyplr} looks very different:
<<>>=
iris %>%
  group_by(Species) %>%
  summarize(mean_sepal_length = mean(Sepal.Length),
            mean_sepal_width = mean(Sepal.Width)) %>%
  as.data.frame()  ## optional but otherwise tibble and not data frame
@
\vfill
Note: this replaces two \texttt{tapply()} calls and remains easy to read.\\
\end{frame}


\subsection{\texttt{dplyr}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Some words about \texttt{dplyr} \& co.}
\texttt{dplyr} is part of the growing \texttt{tidyverse} world (\url{https://www.tidyverse.org/}) developped by RStudio:

\begin{center}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-dplyr"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-ggplot2"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-forcats"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-purrr"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-readr"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-stringr"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-tibble"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-tidyr"}
\end{center}
\pause
\begin{columns}[t]
\column{0.45\linewidth}
\begin{block}{\R \ core team}
\begin{itemize}
\item build the core of \r \ and the original \r \ GUI
\item maintain CRAN
\item backward compatibility is the priority
\item limited man power (20 selected volunteers)
\item not commercial (but Microsoft may creep in?)
\end{itemize}
\end{block}
\column{0.45\linewidth}
\begin{block}{RStudio}
\begin{itemize}
\item build RStudio IDE, \texttt{tidyverse} and more
\item \texttt{tidyverse} philosophy: 1 function = 1 action
\item backward compatibility is not the priority
\item 1 leader (Hadley Wickham) + $\sim$ 70 full time employees + tons of volunteers
\item free + commercial
\end{itemize}
\end{block}
\end{columns}
\pause
Note 1: that has led to two quite distinct \r \ dialects

Note 2: more and more users rely on \texttt{tidyverse}\dots

Note 3: we will see a bit of both dialects
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Some words about \texttt{dplyr} \& co.}
\begin{center}
\includegraphics[height = 0.8\textheight]{../figures/Wickham_r4ds}
\end{center}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{dplyr}}
\begin{itemize}
\item in \texttt{dplyr} one verb = one operation (\texttt{tidyverse} philosophy)
\item operations can be chained with the pipe operator \texttt{\%>\%} (from package \texttt{magrittr}), which considers the output from one function as the input of the next function
\end{itemize}
\vfill
\pause
\begin{columns}[t]
\column{0.45\linewidth}
\begin{block}{Pros}
\begin{itemize}
\item clear code
\item consistent
\item powerful
\item fast
\item many tutorials
\end{itemize}
\end{block}
\pause
\column{0.45\linewidth}
\begin{block}{Cons}
\begin{itemize}
\item different \& redundant
\item buggy (but less \& less so)
\item poor help within \r
\item lead to bad habits (e.g. arguments not named, help not looked at)
\item broaden the gap between users and programmers
\end{itemize}
\end{block}
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{dplyr} verbs}
Useful \texttt{dplyr} functions:\\
\vfill
\begin{itemize}
\item add column with \texttt{mutate()}
<<edit df dplyr>>=
dataframe_ht <- dataframe_ht %>% mutate(ID = 1:nrow(dataframe_ht))  ## transmute() is similar but only keeps new columns
head(x = dataframe_ht, n = 3)
@
\vfill
\pause
\item select columns with \texttt{select()}
<<select dplyr>>=
dataframe_ht_sex <- dataframe_ht %>% select(Sex)
head(x = dataframe_ht_sex, n = 3)
@
\vfill
\pause
\item select rows with \texttt{filter()}
<<filter dplyr>>=
dataframe_ht_female <- dataframe_ht %>% filter(Sex == "girl")
head(dataframe_ht_female, n = 3)
@
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Around \texttt{dplyr} verbs}
All these functions have many derivatives and some of them can be useful:\\
e.g. \texttt{mutate\_if} performs mutation if a condition is fulfilled, which could be useful for example if you want to change all numeric variables into character variables:
\vfill
\begin{columns}
\column{0.45\linewidth}
you have:
<<mutate if, echo = F >>=
str(iris)
@
\column{0.45\linewidth}
you want:
<<mutate if out, echo = F >>=
str(as.data.frame(iris %>% mutate_if(is.numeric, ~ as.character(.))))
@
\end{columns}
\vfill
you do:
<<mutate if solution, echo = T>>=
iris_numeric <- iris %>% mutate_if(is.numeric, ~ as.character(.))
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{group\_by()}}
The \texttt{group\_by()} function allows you to perform operation on gouped data.\\
\vfill
\pause
It is very powerful when combined to:
\begin{itemize}
\item \texttt{summarize()} $\rightarrow$ one value per group
\vfill
\pause
\item \texttt{mutate()} or \texttt{transmute()} $\rightarrow$ one value per observation
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{group\_by() with summarize()}
\begin{center}
You want the mean height of males and females, the median height and the number in
each group:
\end{center}
\vfill
you do:
<<group_by summarize dplyr>>=
x <- dataframe.ht %>%
  group_by(Sex) %>%
  summarize(mean_H = mean(Height, na.rm = T),
            median_H = median(Height, na.rm = T),
            n = n())
@
\vfill
you get:
<<group_by summarize out>>=
as.data.frame(x)
@

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{group\_by() with mutate()}
\begin{center}
You want the mean height of males and females, the median height and the number in
each group but get the value for each individual
\end{center}
\vfill
you do:
<<group_by mutate dplyr>>=
x <- dataframe.ht %>%
  group_by(Sex) %>%
  mutate(mean_H = mean(Height, na.rm = T),
            median_H = median(Height, na.rm = T),
            n = n())
@
\vfill
you get:
<<group_by mutate out>>=
as.data.frame(x)
@

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{joining data frame}

 << merging df: creating df2, echo = F>>=
  set.seed(1)
   my_df1 <- data.frame(ID = paste("ID", 1:12, sep = "-"),
                        age = rnorm(12, mean = 15, sd = 4))

  my_df2 <- data.frame(ID = sample(my_df1$ID),
                       school = rep(c("Youhou", "bababa", "genius"), 4),
                       grade = round(rnorm(12, mean = 60, sd = 20), 2),
                       origin = sample(rep(c("Swiss", "French", "German"), 4)))

  my_df2 <- my_df2[1:10, ]
  my_df1 <- my_df1[c(1:6, 11), ]
  @
\begin{columns}
\column{0.3\linewidth}
\begin{center}
you have df1:
 << merging df df1, echo = T>>=
  my_df1
  @
\end{center}
\column{0.3\linewidth}
\begin{center}
you have df2:
 << merging df df2, echo = T>>=
  my_df2
  @
\end{center}
\end{columns}
\vfill
\begin{center}
You want to merge the two data frames
\end{center}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{joining data frame with base R}
\begin{center}
You can use \texttt{merge()}
\end{center}
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
   << merging df with merge, echo = T>>=
  my_df3 <- merge(my_df1, my_df2)
  @
\end{center}
\column{0.3\linewidth}
\begin{center}
   << merging df with merge output, echo = T>>=
  my_df3
    @
\end{center}
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{joining data frame with dpylr join()}
\begin{center}
or use \texttt{inner\_join()}
\end{center}
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
   << merging df with dplyr join, echo = T>>=
  library(dplyr)
  my_df3 <- inner_join(my_df1, my_df2)
  @
\end{center}
\column{0.3\linewidth}
\begin{center}
   << merging df with merge dplyr join out, echo = T>>=
  my_df3
    @
\end{center}
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{joining data frame with left\_join()}
\begin{center}
\texttt{left\_join() or right\_join()} keep all the rows of the data frame on the left (or right)
\end{center}
\begin{center}
adds NA when no data are present
\end{center}
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
<< left join, echo = T>>=
library(dplyr)
my_df3 <- left_join(my_df1, my_df2)
@
\end{center}
\column{0.3\linewidth}
\begin{center}
<< left join out, echo = T>>=
my_df3
@
\end{center}
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{joining data frame with full\_join()}
\begin{center}
\texttt{full\_join()} keep all the rows of the two data frame
\end{center}
\begin{center}
adds NA when no data are present
\end{center}
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
   << full join, echo = T>>=
  library(dplyr)
  my_df3 <- full_join(my_df1, my_df2)
  @
\end{center}
\column{0.3\linewidth}
\begin{center}
   << full join out, echo = T>>=
  my_df3
    @
\end{center}
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{tidyr}
\begin{frame}[fragile]{reshaping data frame}
\begin{itemize}
\item one row = one observation, one column = one variable
\pause
\vfill
\item \texttt{gather()} turns wide data into long
\pause
\vfill
\item \texttt{spread()} turns long data into wide
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{reshaping data frame}
 << reshaping data frame, echo = FALSE>>=
library(dplyr)
library(tidyr)
  my_df1 <- dataframe.ht %>%
    mutate(age1 = Height -100, age2 = Height -25, age3 = Height -10) %>%
    rename(age4 = Height) %>% select(ID, Sex, age1, age2, age3, age4) %>%
    filter(ID == 1)

  my_df2 <- my_df1 %>% gather("Age", "Height", 3:ncol(my_df1)) %>% arrange(ID, Age)

  @
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
you have wide data:
 << reshaping df1, echo = T>>=
  head(my_df1)
  dim(my_df1)
  @
\end{center}

\column{0.3\linewidth}
\begin{center}
you want long data:
 << reshaping df2, echo = T>>=
  head(my_df2)
  dim(my_df2)
  @
\end{center}
\end{columns}

\vfill
\pause
\begin{columns}
\column{0.5\linewidth}
\begin{center}
you do:
 << reshaping solution, echo = T>>=
 my_df2 <- my_df1 %>% gather("Age", "Height", -Sex, -ID) %>% arrange(ID, Age)
  @
\end{center}
\end{columns}
\pause
\begin{columns}
\column{0.5\linewidth}
\begin{center}
or:
 << reshaping solution bis, echo = T>>=
 my_df2 <- my_df1 %>% gather("Age", "Height", 3:ncol(my_df1)) %>% arrange(ID, Age)
  @
\end{center}
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{reshaping data frame}
The reverse is done with \texttt{spread()}
\vfill
\begin{columns}
\column{0.3\linewidth}
\begin{center}
you have wide data:
 << reshaping df1 spread, echo = T>>=
  head(my_df2)
  dim(my_df2)
  @
\end{center}

\column{0.3\linewidth}
\begin{center}
you want long data:
 << reshaping df2 spread, echo = T>>=
  head(my_df1)
  dim(my_df1)
  @
\end{center}
\end{columns}

\vfill
\pause
\begin{columns}
\column{0.5\linewidth}
\begin{center}
you do:
 << reshaping solution spread, echo = T>>=
 my_df2 %>% spread(-Sex, -ID)
  @
\end{center}
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{some other useful functions}

\texttt{unite()} merges 2 columns of a data frame
 << unite, echo = T>>=
my_df3 <- my_df2 %>% unite(New_col, ID, Sex)
head(my_df3)
  @
\pause
\vfill
\texttt{separate()} separate 2 columns of a data frame
 << separate, echo = T>>=
my_df3 %>% separate(New_col, c("ID", "Sex"))
  @
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{cheating data frame}
\begin{center}
plenty of informative cheatsheets on: \url{https://www.rstudio.com/resources/cheatsheets/}
% \includegraphics[width=0.9\linewidth]{../figures/data-transformation.pdf}
\end{center}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Summary}
\begin{columns}
\column[t]{0.3\linewidth}
<<>>=
dataframe.ht
@
\column[t]{0.3\linewidth}
<<>>=
list.ht
@
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Summary}
  \begin{itemize}
  \item \texttt{data.frame}
  \vfill
  \begin{itemize}
    \item All columns have same length
    \item Each column can have its own class (e.g. \texttt{numeric}, \texttt{factor}, \texttt{character})
  \end{itemize}
  \vfill
  \item \texttt{list}
  \vfill
  \begin{itemize}
    \item Each element can have its own length
    \item Each element can have its own class (e.g. \texttt{numeric}, \texttt{factor}, \texttt{character})
  \end{itemize}
  \vfill
  \end{itemize}
\end{frame}

\section{Importing \& exporting data}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Working directory}
<<>>=
getwd()  # to change, use setwd()
dir() # listing all files in the working directory
dir(pattern = "*.csv")
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Exporting and importing data in R}
<<tidy=F, eval = FALSE>>=
write.csv(dataframe.ht,
    file = "my.first.R.dataframe.csv", row.names = FALSE)

rm(list = ls())  # deleting everything in R

dataframe.ht <- read.csv("my.first.R.dataframe.csv")
@
\begin{center}
\begin{minipage}{0.8\linewidth}
\begin{block}{}
\begin{center}
R cannot read/write \*.xls files out of the box\\
Packages can do that but it is safer to use \*.csv files\\
Excel can read and write \*.csv files!\\
\end{center}
\end{block}
\end{minipage}
\end{center}
\vfill
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Challenge \#2}
\begin{large}
\begin{center}
Create a dataframe using your favorite spreadsheet software\\ and import it in R!
\end{center}
\end{large}
\end{frame}

\end{document}
