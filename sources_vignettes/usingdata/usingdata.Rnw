\documentclass[xcolor=dvipsnames, aspectratio=1610, 9pt]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} % so that dollar sign does not turn into pound when italic!!
\usepackage{amsmath,amssymb,lmodern} % nice T1 compatible fonts
\usepackage[UKenglish]{babel}
\usepackage{ragged2e}%pour justifier le text, apr√®s il suffit de tapper \justifying avant le paragraphe
\setbeamertemplate{navigation symbols}{}%no nav symbols
\usetheme[secheader]{Madrid}%

\def\R{{\Large \bf R}}
\def\S{{\Large \bf S}}
\def\r{{\bf R}}
\def\s{{\bf S}}

\title{Getting to use data in \r}
\author[Alexandre Courtiol \& Colin Vullioud]{Alexandre Courtiol \& Colin Vullioud}
\institute[IZW]{Leibniz Institute of Zoo and Wildlife Research}%
\date[June 2018]{\small June 2018}%

\begin{document}
\setlength{\topsep}{1pt}%space between input and output
<<echo = FALSE, message = FALSE>>=
options(width = 60)
library(knitr)
opts_chunk$set("size" = "scriptsize")
@

\AtBeginSection[]{
     \begin{frame}
     \frametitle{Getting started with \R}
     \setcounter{tocdepth}{1}
     \tableofcontents[currentsection]
     \end{frame}
}

\AtBeginSubsection[]{
     \begin{frame}
     \frametitle{Getting started with \R}
     \setcounter{tocdepth}{2}
     \tableofcontents[currentsubsection]
     \end{frame}
}
% first slide of the doc
\maketitle

\section{Introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Handling data in \r}
There are many types of objects designed to store data in \r.

\vspace{1em}
We will focus on:
\begin{itemize}
\item vectors
\item matrices (and arrays)
\item data frames (and tibbles)
\item lists
\end{itemize}
\vfill
Note: if you master those, we are pretty much all set because most other objects derive from those!
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Handling data in \r}
\begin{itemize}
  \item vectors
  \vfill
  \begin{itemize}
    \item a single row of data
    \item all elements have the same type (e.g. \texttt{logical}, \texttt{integer}, \texttt{double}, \texttt{character}\dots)
  \end{itemize}
  \vfill
  \item matrices (and arrays)
  \vfill
  \begin{itemize}
    \item all rows \& columns have same length
    \item all rows \& columns have the same type
  \end{itemize}
  \vfill
  \item data frames (and tibbles)
  \vfill
  \begin{itemize}
    \item all rows \& columns have same length
    \item each column can have its own type
  \end{itemize}
  \vfill
  \item lists
  \vfill
  \begin{itemize}
    \item each element can have its own length
    \item each element can have its own type
  \end{itemize}
  \end{itemize}
  \vfill
\end{frame}


\section{Vectors}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Vector}
\begin{center}
The vector is the simplest way to store data in \r; it is a sequence of data elements of the same kind.%
\end{center}
\vfill
Example of a vector:
<<defining heights, echo = T>>=
height_girls <- c(178, 175, 159, 164, 183, 192)
height_girls
@
\end{frame}

\subsection{general properties}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: general properties}
They can be combined:

\vfill
<< combining heights, echo = T>>=
height_boys <- c(181, 189, 174, 177)
height <- c(height_boys, height_girls)
height
@
\vfill
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: general properties}
Subsets can be made (with indexes, booleans or names):%

\vfill
<<printing indexes height, echo = T>>=
height_girls[2]  ## returns element 2
height_girls[-3] ## remove element 3
@
\vfill
\pause
<<boolean rep, echo = T>>=
height_girls[c(1, 1, 2, 2, 2)]  ## open room for bootstraps and more
@
\vfill
\pause
<<boolean heights, echo = T>>=
height_girls[height_girls > 168]
height_girls[!(height_girls == min(height_girls))]
height_girls[height_girls != min(height_girls)]
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[t, fragile]{Vector: general properties}
The elements of a vector can be named and those names can be used for subsetting:%

\vfill
<<>>=
foo <- c(alex = 1, colin = 2)
foo
foo["colin"]
@
\vfill
\pause
But names behave sometimes somewhat unexpectedly:
<<>>=
foo[1] + foo[2]
@
\vfill
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[t, fragile]{Vector: general properties}
Vectors (as any other object) can have metadata called `attributes' attached to them:
\vfill
<<>>=
foo <- c(1, 2, 3)
attr(x = foo, which = "whatever") <- "Learning to count"
attr(x = foo, which = "something else?") <- "nope"
@

<<>>=
foo
@
\pause
<<>>=
attr(x = foo, which = "whatever")
@
\pause
<<>>=
attributes(foo) ## this gives a list, see later!
@
\vfill
Note: this is useful to know for handling outputs in certain packages (e.g. \texttt{spaMM}).
\end{frame}


\subsection{types \& classes}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: types}
Types refer to the internal representation of the objects:
\begin{columns}
\column{0.45\linewidth}
\begin{itemize}
\item logicals
<<>>=
(foo <- c(TRUE, FALSE, F, T))
typeof(x = foo)
@
\pause
\item integers
<<>>=
(foo <- c(1L, 5L, 7L, 0L))
typeof(x = foo)
@
\end{itemize}
\pause
\column{0.45\linewidth}
\begin{itemize}
\item doubles
<<>>=
(foo <- c(1, 1.2, pi))
typeof(x = foo)
@
\pause
\item characters
<<>>=
(foo <- c("bla", "bli", "blo"))
typeof(x = foo)
@
\end{itemize}
\end{columns}
\vfill
\pause
Note: \r \ detects automatically the type of input and creates the right type of vector for you!
\vspace{1em}
Challenge: compare \texttt{typeof()} with \texttt{mode()}. % mode is the same except that doubles and integers are called numerics (and a few other name changes)
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: classes}
Classes refer to the how functions interact with the objects:
\begin{columns}
\column{0.45\linewidth}
\begin{itemize}
\item logicals
<<>>=
(foo <- c(TRUE, FALSE, F, T))
class(x = foo)
@
\item integers
<<>>=
(foo <- c(1L, 5L, 7L, 0L))
class(x = foo)
@
\end{itemize}
\column{0.45\linewidth}
\begin{itemize}
\item numerics (from the type doubles)
<<>>=
(foo <- c(1, 1.2, pi))
class(x = foo)
@
\item characters
<<>>=
(foo <- c("bla", "bli", "blo"))
class(x = foo)
@
\end{itemize}
\end{columns}
\vfill
Note: many don't make the distinction between types and classes explicit but it helps to understand some weird behaviours of \r.
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: classes}
There are more classes than types:
\begin{columns}[t]
\column{0.45\linewidth}
\begin{itemize}
\item factors
<<>>=
(foo <- factor(c("bla", "bli", "blo")))
class(x = foo)
typeof(x = foo)
levels(x = foo)

levels(x = foo) <- c(levels(x = foo), "blu")  ## set extra level
table(foo)
@
\end{itemize}
\pause
\column{0.45\linewidth}
\begin{itemize}
\item dates
<<>>=
(foo <- c(as.Date(x = "2018/06/18"),
          as.Date(x = "19-06-18", format = "%d-%m-%y")))
class(x = foo)
typeof(x = foo)

foo + 50  ## you can do simple maths on dates!
@
\end{itemize}
\end{columns}
\vfill
\pause
Note: factors are heavily used in the context of linear models!
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: classes}
Vectors must contain elements of the same class (otherwise errors or automatic coercion may occur):%

\vfill
<<>>=
foo <- 1

bar <- "A"

foo_bar <- c(foo, bar)
foo_bar
@
\pause
\vfill
<<>>=
foo + 1

foo_bar[1] + 1
@
\pause
\vfill
Challenges:
\begin{itemize}
\item find out why the previous call produces an error.
\item try to check how the automatic coercion occurs by mixing different classes in different ways (logical, integers, numeric, characters, factors).
\item find out which date is internally stored as 0?
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Vector: classes}
Some coercions are straightforward:
<<>>=
as.integer(x = 1.2)
as.integer(x = 1.9)
as.integer(x = -2.1)
@
\vfill
<<>>=
foo <- factor(x = 10:20)
foo
as.character(x = foo)
@
\vfill
\pause
But not all:
<<>>=
as.numeric(x = foo)
as.numeric(as.character(x = foo))
@
\vfill
<<>>=
foo <- as.Date(x = "20180618", format = "%Y%m%d")
as.integer(x = foo)
as.integer(x = gsub(pattern = "-", replacement = "", x = as.character(foo)))
@
\end{frame}


\subsection{factors}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Factors}
You can create them after in two steps:
<< factors sex, echo = T>>=
sex <- c("girl","girl","girl","girl","girl", "girl",
"boy","boy","boy","boy")
class(x = sex)
@

<<>>=
sex <- factor(x = sex)
sex
@
\vfill
\pause
Better code:
<<factors sex other options,echo = T>>=
sex <- factor(x = c(rep(x = "girl", times = 6),
                    rep(x = "boy", times = 4)))
@
\vfill
Even better code:
<<>>=
sex <- factor(x = c(rep(x = "girl", times = length(x = height_girls)),
                    rep(x = "boy", times = length(x = height_boys))))
@
\vfill
Note: more on programming style later!
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Combining vectors with different levels}
We want to merge the two following vectors:
\vspace{1em}
<<>>=
foo <- factor(c("a", "b"))
foo
@
<<>>=
bar <- factor(c("b", "c"))
bar
@
\vfill
\pause
\begin{columns}[t]
\column{0.45\linewidth}
Problem:
<<>>=
foo_bar <- c(foo, bar)
foo_bar
class(foo_bar)
@
\pause
\column{0.45\linewidth}
Solution:
<<>>=
foo_bar <- factor(c(as.character(foo), as.character(bar)))
foo_bar
class(foo_bar)
@
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Dropping unused levels}
By default \r \ keeps unused levels:
<<>>=
foo <- factor(c("a", "a", "b", "c"))
foo
@
<<>>=
table(foo)
@
<<>>=
bar <- foo[-4]
table(bar)
@
\vfill
\pause
If you want to update the levels you need to use the function \texttt{droplevels}:
<<>>=
new_bar <- droplevels(bar)
table(new_bar)
@
Or use the argument \texttt{drop}:
<<>>=
bar <- foo[-4, drop = TRUE]
table(bar)
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Changing the order of levels of a factor}
<< changing levels order, echo = FALSE>>=
my_factor1 <- factor(x = c("A", "A", "B", "B", "C"))
my_factor2 <- factor(x = c("A", "A", "B", "B", "C"), levels = c("C", "B", "A"))
@

\begin{columns} % create columns
  \column{0.2\linewidth}
  \begin{center}
  You have:
  <<displaying factor1>>=
  my_factor1
  @
  \end{center}
  \column{0.2\linewidth}
  \begin{center}
  You want:
  <<displaying factor2>>=
  my_factor2
  @
  \end{center}
\end{columns}

\pause

  \begin{columns}
    \column{0.5\linewidth}

    \begin{center}
    You do:
    <<solutions factors order>>=
    my_factor2 <- factor(x = my_factor1, levels = levels(my_factor1)[c(3, 2, 1)])
    my_factor2
    @
    \pause
    Or if you only care about the first level:
    <<solutions factors order 2>>=
    my_factor3 <- relevel(x = my_factor1, ref = "C")
    my_factor3
    @
    \end{center}
  \end{columns}
  \vfill

\pause

Note:
the order of levels influences the meaning of parameter estimates in linear models and some plotting functions (e.g. order in the legend of a ggplot) \dots
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Changing the levels of a factor}
<<changing levels, echo = FALSE>>=
my_factor1 <- factor(x = c("A", "A", "B", "B", "C"))
my_factor2 <- factor(x = c("A", "A", "A", "A", "D"))
@

\begin{columns}
\column{0.2\linewidth}
\begin{center}
You have:
<<changing levels 1 >>=
my_factor1
@
\end{center}

\column{0.2\linewidth}
\begin{center}
You want:
<<changing levels 2>>=
my_factor2
@
\end{center}
\end{columns}
\pause
\begin{columns}
\column{0.5\linewidth}

\begin{center}
You do:
<<changing levels solution>>=
## Using base:
levels(x = my_factor1)
my_factor2 <- my_factor1
levels(x = my_factor2) <- c("A", "A", "D") ## in same order!
my_factor2
@
\pause
<<changing levels solutions dplyr, message = FALSE>>=
## Using dplyr:
library(dplyr)
my_factor2 <- recode(.x = my_factor1, A = "A", B = "A", C = "D")
my_factor2
@
\end{center}
\end{columns}
\vfill
\pause
Note: if you want more modern functions to manipulate factors, look at the package \texttt{forcats} from \texttt{tidyverse}.
\end{frame}


\subsection{functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Some simple functions for vectors}
<<>>=
foo <- c("bla", "bla", "bli")
bar <- c(1, 1.2, pi, NA)
@
\begin{columns}
\column{0.45\linewidth}
<<>>=
any(is.na(x = foo))
unique(x = foo)
length(x = foo)
str(object = foo)
summary(object = foo)
@
\pause
\column{0.45\linewidth}
<<>>=
any(is.na(x = bar))
unique(x = bar)
length(x = bar)
str(object = bar)
summary(object = bar)
@
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{A more complex function: \texttt{sapply()}}
\texttt{sapply()} is a function to apply a function on each element of a vector:
<<>>=
triple <- function(x) c(x, x, x)  ## let us create a sily function
triple(x = "a")
@

<<>>=
sapply(X = bar, FUN = triple) ## here returns a matrix (automatic choice)
@
\pause
<<>>=
sapply(X = bar, FUN = triple, simplify = FALSE) ## same but always returns a list
@
\vfill
\pause
Note 1: this is useful when the function cannot work on vector and when the return is more than one element. For example, the input could be a vector of file names and the output one dataset per file!
\vfill
\pause
Note 2: if you want more modern functions more consistent than the \texttt{*apply()} ones, look at the package \texttt{purrr} from \texttt{tidyverse}.
\vfill
\pause
Challenge: can you think of an alternative to do that without using \texttt{sapply()}? %subsetting
\end{frame}


\section{Matrices and arrays}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Matrices \& arrays}
\begin{center}
The matrices and arrays are direct extentions of vectors when there is more than one dimension \\ (1 or 2 dimensions for matrices, any for arrays).
\end{center}
\vfill
Example of a matrix:
<<>>=
my_matrix <- matrix(data = 1:12, ncol = 4, nrow = 3)
my_matrix
class(x = my_matrix)
typeof(x = my_matrix) ## behind the curtain, matrices are stored as vectors!
@
\vfill
\pause
Note 1: since there are a kind of vectors, the same restrictions apply: all elements must have the same class!

Note 2: useful for bulding the input of some statistical tests (e.g. chi-square), for linear algebra (e.g. computation behind linear models), for handling GIS information \& for understanding data frames.
\end{frame}


\subsection{general properties}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Matrices: general properties}
They can be combined:

\vfill
<<>>=
(my_2nd_matrix <- matrix(data = 13:18, ncol = 2, nrow = 3))
(my_3rd_matrix <- matrix(data = 1:4, nrow = 1))
@
\vfill
\pause
<<>>=
cbind(my_matrix, my_2nd_matrix)  ## bind columns
@
\pause
\vfill
<<>>=
rbind(my_matrix, my_3rd_matrix)  ## bind rows
@
\vfill
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Matrices: general properties}
Subsets can be made (with indexes, booleans or names):%

\vfill
<<>>=
my_matrix[2, ]
my_matrix[, 1]
my_matrix[3, , drop = FALSE]  ## to keep a matrix
my_matrix[2, 1]
my_matrix[c(1:2), c(1:2)]
@
\vfill
\pause
<<>>=
colnames(x = my_matrix) <- c("A", "B", "C", "D")
rownames(x = my_matrix) <- c("a", "b", "c")
my_matrix
my_matrix["b", ]
@
\end{frame}


\subsection{functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Some simple functions for matrices}
\begin{columns}[t]
\column{0.45\linewidth}
Dimensions:
<<>>=
dim(x = my_matrix)
ncol(x = my_matrix)
nrow(x = my_matrix)
length(x = my_matrix)
@
\vspace{1em}
Names:
<<>>=
colnames(x = my_matrix)
rownames(x = my_matrix)
@
\column{0.45\linewidth}
Linear algebra:
<<>>=
t(x = my_matrix)  ## transpose
my_matrix %*% c(1:4) ## matrix multiplication
diag(x = my_matrix) ## extract diagonal
@
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{A more complex function: \texttt{apply()}}
\texttt{apply()} is a function to apply a function on each row or column of a matrix:
<<>>=
apply(X = my_matrix, MARGIN = 1, FUN = mean)  ## row means
apply(X = my_matrix, MARGIN = 2, FUN = sd)  ## column SDs
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Arrays?}
Arrays are very similar to matrices but allow for more dimensions:
<<>>=
foo <- array(data = 1:8, dim = c(2, 2, 2))
foo
@
\vfill
<<>>=
foo[1, 2, 2]
apply(X = foo, MARGIN = 3, FUN = sum)
@
\vfill
Note: only useful in some very specific situations.
\end{frame}


\section{List}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Lists}
\begin{center}
Lists allow the organisation of any set of entities into a single \r \ object.
\end{center}
\vfill
Example of a list:
<<>>=
list_height <- list(height_girls, height_boys)
list_height
class(x = list_height)
typeof(x = list_height)
@
\vfill
Note 1: list elements can be anything!\\
\vspace{1em}
Note 2: lists are very important because no function can output more than one object!
\end{frame}


\subsection{general properties}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Lists: general properties}
They can be combined:
\vfill
<<>>=
list_full <- c(list_height, list(my_matrix))
list_full
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Lists: general properties}
Subsets can be made (with indexes, booleans or names):%
\vfill
<<>>=
list_height <- list(girls = height_girls, boys = height_boys)  ## create a list with names
list_height
@
\vfill
<<>>=
list_height$girls
@
<<>>=
list_height["boys"] ## still a list
@
<<>>=
list_height[["boys"]] ## vector
@
<<>>=
list_height[[2]][3]
@
\vfill
\end{frame}


\subsection{functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Some simple functions for lists}
<<>>=
length(x = list_full) ## number of elements
@
<<>>=
str(object = list_full)  ## this function is really useful!
@
\vfill
Challenge: run the examples from \texttt{lm()} and explore the list \texttt{lm.D9}.
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{A more complex function: \texttt{lapply()}}
\texttt{lapply()} is a function to apply a function on each element of a list:
<<>>=
lapply(X = list_full, FUN = mean)
@
\end{frame}



\section{Data frames and tibbles}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames}
\begin{center}
Data frames allow the organisation of vectors of the same length as a matrix-like structure:
\end{center}
\vfill
Example:
<<create Data frame>>=
dataframe_ht <- data.frame(Height = height, Sex = sex)
dataframe_ht
class(dataframe_ht)
typeof(dataframe_ht)
@
\pause
\vfill
Note 1: this is the best choice of representation for datasets!\\
\vspace{1em}
Note 2: it is safer to work on data frames than on floating vectors!
\end{frame}


\subsection{general properties}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{Data frames: general properties}
They borough from both matrices and lists:
\vfill
\begin{columns}[t]
\column{0.45\linewidth}
As for matrices:
<<>>=
(dataframe_ht_double <- cbind(dataframe_ht, newcol = 1:10))
@
\pause
<<>>=
dataframe_ht[, "Sex"]
dataframe_ht[2, 2]
@
\pause
\column{0.45\linewidth}
As for lists:
<<>>=
dataframe_ht$Height
str(dataframe_ht)
@

\end{columns}
\end{frame}


\subsection{challenge}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames: challenge}
The \texttt{iris} data set:
<<>>=
head(iris) ## this function displays the first 6 rows
@
\vfill
Using the \texttt{iris} data frame, find out:
\begin{itemize}
\item what is the average sepal length across all flowers?
\item what is the median sepal length across \emph{Iris versicolor}?
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Data frames: general properties}
Data frames can easily be edited:
<<edit df>>=
backup <- dataframe_ht[1, 1]
dataframe_ht[1, 1] <- 171.3
dataframe_ht[1, 1]
dataframe_ht[1, 1] <- backup
dataframe_ht[1, 1]
@
\pause
<<>>=
dataframe_ht$linenumber <- 1:nrow(x = dataframe_ht)  # add column
head(x = dataframe_ht)
@
\pause
<<>>=
dataframe_ht$linenumber <- NULL  # remove column
head(x = dataframe_ht)
@
\end{frame}


\subsection{functions}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Some simple functions for data frames}
\begin{columns}[t]
\column{0.45\linewidth}
<<summary df>>=
head(x = iris)  ## try also tail()
summary(object = iris)
@
\column{0.45\linewidth}
<<>>=
dim(x = iris)
ncol(x = iris)
nrow(x = iris)
length(x = iris) ## not as in matrix!!
rownames(x = iris)[1:10]
colnames(x = iris)
@
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{A more complex function: \texttt{tapply()}}
\texttt{tapply()} is a function to apply a function on subsets of a given column from the data frame:
<<>>=
tapply(X = iris$Sepal.Length, INDEX = iris$Species, FUN = mean)
@
\vfill
\pause
Or similarly:
<<>>=
with(data = iris, tapply(X = Sepal.Length, INDEX = Species, FUN = mean))
@
\vfill
\pause
Or similarly:
<<>>=
by(data = iris, INDICES = iris$Species, FUN = function(x) mean(x$Sepal.Length))
@
\vfill
Note: \texttt{by()} is more powerful but more complex than \texttt{tapply()}.
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{The \texttt{dyplr} alternative to \texttt{tapply()}}
The same operation in \texttt{dyplr} looks very different:
<<>>=
iris %>%
  group_by(Species) %>%
  summarize(mean_sepal_length = mean(Sepal.Length),
            mean_sepal_width = mean(Sepal.Width)) %>%
  as.data.frame()  ## optional but otherwise tibble and not data frame
@
\vfill
Note: this replaces two \texttt{tapply()} calls and remains easy to read.\\
\end{frame}


\subsection{\texttt{dplyr}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Some words about \texttt{dplyr} \& co.}
\texttt{dplyr} is part of the growing \texttt{tidyverse} world (\url{https://www.tidyverse.org/}) developped by RStudio:

\begin{center}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-dplyr"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-ggplot2"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-forcats"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-purrr"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-readr"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-stringr"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-tibble"}
\includegraphics[width = 1.5cm]{"../figures/tidyverse/hex-tidyr"}
\end{center}
\pause
\begin{columns}[t]
\column{0.45\linewidth}
\begin{block}{\R \ core team}
\begin{itemize}
\item build the core of \r \ and the original \r \ GUI
\item maintain CRAN
\item backward compatibility is the priority
\item limited man power (20 selected volunteers)
\item not commercial (but Microsoft may creep in?)
\end{itemize}
\end{block}
\column{0.45\linewidth}
\begin{block}{RStudio}
\begin{itemize}
\item build RStudio IDE, \texttt{tidyverse} and more
\item \texttt{tidyverse} philosophy: 1 function = 1 action
\item backward compatibility is not the priority
\item 1 leader (Hadley Wickham) + $\sim$ 70 full time employees + tons of volunteers
\item free + commercial
\end{itemize}
\end{block}
\end{columns}
\pause
Note 1: that has led to two quite distinct \r \ dialects

Note 2: more and more users rely on \texttt{tidyverse}\dots

Note 3: we will see a bit of both dialects
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Some words about \texttt{dplyr} \& co.}
\begin{center}
\includegraphics[height = 0.8\textheight]{../figures/Wickham_r4ds}
\end{center}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{dplyr}}
\begin{itemize}
\item in \texttt{dplyr} one verb = one action = one function (\texttt{tidyverse} philosophy)
\item operations can be chained with the pipe operator \texttt{\%>\%} (from package \texttt{magrittr}), which considers the output from one function as the input of the next function
\end{itemize}
\vfill
\pause
\begin{columns}[t]
\column{0.45\linewidth}
\begin{block}{Pros}
\begin{itemize}
\item clear code
\item consistent
\item powerful
\item fast
\item many tutorials
\end{itemize}
\end{block}
\pause
\column{0.45\linewidth}
\begin{block}{Cons}
\begin{itemize}
\item different \& redundant
\item buggy (but less \& less so)
\item poor traditional documentation
\item lead to bad habits (e.g. arguments not named, help not looked at)
\item broaden the gap between users and programmers
\end{itemize}
\end{block}
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{dplyr} verbs}
Useful \texttt{dplyr} functions:\\
\vfill
\begin{itemize}
\item add column with \texttt{mutate()}
<<edit df dplyr>>=
dataframe_ht <- dataframe_ht %>% mutate(ID = 1:nrow(dataframe_ht))
head(x = dataframe_ht, n = 3)
@
\vfill
\pause
\item change column with \texttt{transmute()}
<<edit df dplyr2>>=
dataframe_ht2 <- dataframe_ht %>% transmute(double_height = 2*height)
head(x = dataframe_ht2, n = 3)
@
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{dplyr} verbs}
Useful \texttt{dplyr} functions:\\
\vfill
\begin{itemize}
\item select columns with \texttt{select()}
<<select dplyr>>=
dataframe_ht_sex <- dataframe_ht %>% select(Sex)
head(x = dataframe_ht_sex, n = 3)
@
\vfill
\pause
\item select rows with \texttt{filter()}
<<filter dplyr>>=
dataframe_ht_female <- dataframe_ht %>% filter(Sex == "girl")
head(dataframe_ht_female, n = 3)
@
\vfill
\pause
\item sort rows with \texttt{arrange()}
<<sort dplyr>>=
dataframe_ht_sorted <- dataframe_ht %>% arrange(Height)  ## add arrange(desc(Height)) for the other direction
head(dataframe_ht_sorted, n = 3)
@
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Around \texttt{dplyr} verbs}
These main \texttt{dplr} functions have derivatives and some of them can be useful:\\
e.g. \texttt{mutate\_if} performs mutation if a condition is fulfilled, which could be useful for example if you want to change all numeric variables into character variables:
\vfill
\begin{columns}
\column{0.45\linewidth}
you have:
<<mutate if, echo = F >>=
str(iris)
@
\column{0.45\linewidth}
you want:
<<mutate if out, echo = F >>=
str(as.data.frame(iris %>% mutate_if(is.numeric, ~ as.character(.))))
@
\end{columns}
\vfill
you do:
<<mutate if solution, echo = T>>=
iris_numeric <- iris %>%
  mutate_if(is.numeric, ~ as.character(.))
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{\texttt{group\_by()}}
The \texttt{group\_by()} function allows you to perform operation on gouped data.\\
\vfill
\pause
It is very powerful when combined to:
\begin{itemize}
\item \texttt{summarize()} $\rightarrow$ one value per group
\vfill
\pause
\item \texttt{mutate()} or \texttt{transmute()} $\rightarrow$ one value per observation
\vfill
\pause
\item \texttt{slice()} $\rightarrow$ select some rows for each "group"
\end{itemize}
\vfill
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{\texttt{group\_by()} with \texttt{summarize()}}
Example: you want the mean height of males and females, the median height and the number in
each group:
<<group_by summarize dplyr>>=
dataframe_ht %>%
  group_by(Sex) %>%
  summarize(mean_height = mean(Height),
            median_height = median(Height),
            n = n()) %>%
  as.data.frame()
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{\texttt{group\_by()} with \texttt{mutate()}}
Same as before, but we want to repeat the value for each individual:
<<group_by mutate dplyr>>=
dataframe_ht %>%
  group_by(Sex) %>%
  mutate(mean_height = mean(Height),
            median_height = median(Height),
            n = n()) %>%
  as.data.frame()
@
\vfill
Note: many other functions than \texttt{n()} can be used, see \texttt{?summarise} \ !
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile, t]{\texttt{group\_by()} with \texttt{slice()}}
Example: you want the first two rows of each species of irices:
<<>>=
iris %>%
  group_by(Species) %>%
  slice(1:2) %>%
  as.data.frame()
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Challenge}
Use the dataset called \texttt{population\_UK} and compute the total population size for:
\begin{itemize}
\item 1915
\item 2015
\item all years in the dataset
\item all years between 1915 and 2015
\end{itemize}
\vfill
Use the dataset called \texttt{deaths\_UK} and figure out:
\begin{itemize}
\item which were the top 3 detailed causes of death before 1930 for each of the 21 broader categories
\item the death toll for all individuals below 15 yrs for each year
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Using \texttt{dplyr} to merge datasets}
\begin{columns}
\column{0.45\linewidth}
\begin{center}
Data frame \#1:
<<>>=
my_df1 <- iris %>%
  filter(Species == "setosa") %>%
  select(Sepal.Length, Petal.Length, Species) %>%
  slice(1:4)
my_df1[4, 1] <- NA
my_df1
@
\end{center}
\column{0.45\linewidth}
\begin{center}
Data frame \#2:
<<>>=
my_df2 <- iris %>%
  filter(Species == "virginica") %>%
  select(Sepal.Length, Petal.Width, Species) %>%
  slice(1:4)
my_df2[3, 2] <- NA
my_df2
@
\end{center}
\end{columns}
\vfill
\begin{center}
We will see how to merge these two data frames!
\end{center}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Using \texttt{dplyr} to merge datasets}
There are several options but \texttt{full\_join()} is the most effective one: it keeps all the rows of the two data frames and adds NA when no data are present!
\vfill
<<full join>>=
my_df3 <- full_join(my_df1, my_df2)
my_df3
@
\vfill
Note: you can also do that without \texttt{dplyr} but the outcome is a bit more messy:
<<eval = FALSE>>=
merge(my_df1, my_df2, all = TRUE)
@
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Challenge}
Use the datasets called \texttt{population\_UK} and  \texttt{deaths\_UK} to compute yearly mortality rates for:
\begin{itemize}
\item all individuals
\item individuals below 15 yrs only
\end{itemize}
\end{frame}


\subsection{tidyr}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Reshaping data frame}
For most data analyses, you need:
\begin{center}
\begin{minipage}{0.3\linewidth}
\begin{block}{}
\begin{itemize}
\item one row = one observation
\item one column = one variable
\end{itemize}
\end{block}
\end{minipage}
\end{center}
\vfill
Unfortunatelly, it is often not the way people input data!
\vfill
\pause
The \texttt{tidyverse} package \texttt{tidyr} offers solutions:
\begin{itemize}
\item \texttt{gather()} turns wide data into long
\item \texttt{spread()} turns long data into wide
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{From wide to long}
 << reshaping data frame, echo = FALSE>>=
  my_df1 <- dataframe_ht %>%
    mutate(age1 = Height -100, age2 = Height -25, age3 = Height -10) %>%
    rename(age4 = Height) %>% select(ID, Sex, age1, age2, age3, age4) %>%
    filter(ID == 1)

  my_df2 <- my_df1 %>% tidyr::gather("Age", "Height", 3:ncol(my_df1)) %>% arrange(ID, Age)

  @
\vfill
\begin{columns}[t]
\column{0.3\linewidth}
\begin{center}
you have:
 << reshaping df1, echo = T>>=
  head(my_df1)
  dim(my_df1)
  @
\end{center}

\column{0.3\linewidth}
\begin{center}
you want:
 << reshaping df2, echo = T>>=
  head(my_df2)
  dim(my_df2)
  @
\end{center}
\end{columns}

\vfill
\pause
\begin{columns}
\column{0.5\linewidth}
\begin{center}
you do:
 << reshaping solution, echo = T>>=
library(tidyr)
my_df2 <- my_df1 %>%
  gather("Age", "Height", -Sex, -ID) %>%
  arrange(ID, Age)
@
\end{center}
\end{columns}
\pause
\begin{columns}
\column{0.5\linewidth}
\begin{center}
or:
<< reshaping solution bis, echo = T>>=
my_df2 <- my_df1 %>%
  gather("Age", "Height", 3:ncol(my_df1)) %>%
  arrange(ID, Age)
@
\end{center}
\end{columns}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{From long to wide}
\begin{columns}[t]
\column{0.3\linewidth}
\begin{center}
you have:
<< reshaping df1 spread, echo = T>>=
head(my_df2)
dim(my_df2)
@
\end{center}

\column{0.3\linewidth}
\begin{center}
you want:
<< reshaping df2 spread, echo = T>>=
head(my_df1)
dim(my_df1)
@
\end{center}
\end{columns}
\vfill
\pause
\begin{columns}
\column{0.5\linewidth}
\begin{center}
you do:
<< reshaping solution spread, echo = T>>=
my_df2 %>%
  spread(-Sex, -ID)
@
\end{center}
\end{columns}
\vfill
Note: but why on Earth would you need that?!
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Some other useful functions from \texttt{tidyr}}

\texttt{unite()} merges 2 columns of a data frame:
 << unite, echo = T>>=
my_df3 <- my_df2 %>% unite(New_col, ID, Sex)
head(my_df3)
@
\pause
\vfill
\texttt{separate()} splits 2 columns of a data frame:
<< separate, echo = T>>=
my_df3 %>% separate(New_col, c("ID", "Sex"))
@
\vfill
\pause
Note: the \r \ base equivalent are \texttt{paste()} and \texttt{strsplit()} but they are a bit more tedious to use.
\end{frame}


\section{Importing \& exporting data}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Working directory}
Before anything, you must know where you read \& write on your hard drive!
<<>>=
getwd() ## get the working directory, to change it use setwd()
dir() ## list all files in the working directory
dir(pattern = "*.csv")  ## list all files with the extension csv
@
\vfill
Note: you can also set this up with RStudio but it won't be saved unless you set up a project file.
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Exporting and importing data in the \R \ binary format}
\r \ can write and read binary formats that take by convention the extensions *.rda or *.RData.
\vfill
Example:
<<>>=
my_iris <- iris
save(my_iris, file = "my_iris.rda") ## check the help for compression
@
\vfill
\pause
<<>>=
rm(list = ls()) ## removes everything!
head(my_iris)
@
\pause
\vfill
<<>>=
load(file = "my_iris.rda")
head(my_iris)
@
<<echo = FALSE>>=
system("rm my_iris.rda")
@
\vfill
Note: this is useful and best for \r \ to \r \ exchanges (but it is useless without \r).
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]{Exporting and importing data sets in plain text}
\begin{center}
\begin{minipage}{0.8\linewidth}
\begin{block}{}
\begin{itemize}
\item \r \ cannot read/write \*.xls(x) files out of the box\\
\item Several packages can do that, but it is safer to use \*.csv or \*.txt files\\
\item Excel can read and write \*.csv \& \*.txt files!\\
\end{itemize}
\end{block}
\end{minipage}
\end{center}
\vfill
Writing a data set:
<<tidy=F>>=
write.csv(my_iris, file = "my_iris.csv", row.names = FALSE)
@
\vfill
\pause
Reading a data set:
<<>>=
rm(my_iris) ## delete the object my_iris
my_iris <- read.csv("my_iris.csv")
head(my_iris)
@
<<echo = FALSE>>=
system("rm my_iris.csv")
@
\vfill
\pause
Note 1: always check your file in a text editor before importing it or use RStudio "File/Import Datasets GUI".
\vfill
Note 2: you will have often to change the arguments \texttt{sep} (and \texttt{dec} if you are german).
\vfill
Note 3: setting \texttt{stringsAsFactors = FALSE} can avoid a lot of troubles!
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}{Challenge}
\begin{large}
\begin{center}
Create a data frame using your favorite spreadsheet software (or choose an existing one)\\ and import it in \R.
\end{center}
\end{large}
\end{frame}

\end{document}
